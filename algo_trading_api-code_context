# File: lib/DhanHQ/client.rb
# frozen_string_literal: true

require "faraday"
require "json"
require "active_support/core_ext/hash/indifferent_access"
require_relative "errors"
require_relative "rate_limiter"

module DhanHQ
  # The `Client` class provides a wrapper for HTTP requests to interact with the DhanHQ API.
  # Responsible for:
  # - Establishing and managing the HTTP connection
  # - Handling authentication and request headers
  # - Sending raw HTTP requests (`GET`, `POST`, `PUT`, `DELETE`)
  # - Parsing JSON responses into HashWithIndifferentAccess
  # - Handling standard HTTP errors (400, 401, 403, etc.)
  # - Implementing **Rate Limiting** to avoid hitting API limits.
  #
  # It supports `GET`, `POST`, `PUT`, and `DELETE` requests with JSON encoding/decoding.
  # Credentials (`access_token`, `client_id`) are automatically added to each request.
  #
  # @see https://dhanhq.co/docs/v2/ DhanHQ API Documentation
  class Client
    include DhanHQ::RequestHelper
    include DhanHQ::ResponseHelper
    # The Faraday connection object used for HTTP requests.
    #
    # @return [Faraday::Connection] The connection instance used for API requests.
    attr_reader :connection

    # Initializes a new DhanHQ Client instance with a Faraday connection.
    #
    # @example Create a new client:
    #   client = DhanHQ::Client.new(api_type: :order_api)
    #
    # @param api_type [Symbol] Type of API (`:order_api`, `:data_api`, `:non_trading_api`)
    # @return [DhanHQ::Client] A new client instance.
    def initialize(api_type:)
      DhanHQ.configure_with_env if ENV.fetch("CLIENT_ID", nil)
      @rate_limiter = RateLimiter.new(api_type)

      raise "RateLimiter initialization failed" unless @rate_limiter

      @connection = Faraday.new(url: DhanHQ.configuration.base_url) do |conn|
        conn.request :json, parser_options: { symbolize_names: true }
        conn.response :json, content_type: /\bjson$/
        conn.response :logger if ENV["DHAN_DEBUG"] == "true"
        conn.adapter Faraday.default_adapter
      end
    end

    # Sends an HTTP request to the API.
    #
    # @param method [Symbol] The HTTP method (`:get`, `:post`, `:put`, `:delete`)
    # @param path [String] The API endpoint path.
    # @param payload [Hash] The request parameters or body.
    # @return [HashWithIndifferentAccess, Array<HashWithIndifferentAccess>] Parsed JSON response.
    # @raise [DhanHQ::Error] If an HTTP error occurs.
    def request(method, path, payload)
      @rate_limiter.throttle! # **Ensure we don't hit rate limit before calling API**

      response = connection.send(method) do |req|
        req.url path
        req.headers.merge!(build_headers(path))
        prepare_payload(req, payload, method)
      end

      handle_response(response)
    end

    # Convenience wrappers for common HTTP methods. These make it easier to stub
    # network calls in tests where `request` is invoked internally.
    def get(path, params = {})
      request(:get, path, params)
    end

    def post(path, params = {})
      request(:post, path, params)
    end

    def put(path, params = {})
      request(:put, path, params)
    end

    def delete(path, params = {})
      request(:delete, path, params)
    end
  end
end


# File: lib/DhanHQ/config.rb
# frozen_string_literal: true

require "logger"

module DhanHQ
  class << self
    # keep whatever you already have; add these if missing:
    attr_accessor :client_id, :access_token, :base_url, :ws_version

    # default logger so calls like DhanHQ.logger&.info never explode
    def logger
      @logger ||= Logger.new($stdout, level: Logger::INFO)
    end

    attr_writer :logger

    # same API style as your README
    def configure
      yield self
      # ensure a logger is present even if user didn’t set one
      self.logger ||= Logger.new($stdout, level: Logger::INFO)
    end

    # if you support env bootstrap
    def configure_with_env
      self.client_id    = ENV.fetch("CLIENT_ID", nil)
      self.access_token = ENV.fetch("ACCESS_TOKEN", nil)
      self.base_url   ||= "https://api.dhan.co/v2"
      self.ws_version ||= 2
    end
  end
end


# File: lib/DhanHQ/configuration.rb
# frozen_string_literal: true

module DhanHQ
  # The `Configuration` class manages API credentials and settings.
  #
  # Use this class to set the required `access_token` and `client_id`, as well as optional
  # settings such as the base URL and CSV URLs.
  #
  # @see https://dhanhq.co/docs/v2/ DhanHQ API Documentation
  class Configuration
    BASE_URL = "https://api.dhan.co/v2"
    # The client ID for API authentication.
    # @return [String, nil] The client ID or `nil` if not set.
    attr_accessor :client_id

    # The access token for API authentication.
    # @return [String, nil] The access token or `nil` if not set.
    attr_accessor :access_token

    # The base URL for API requests.
    # @return [String] The base URL for the DhanHQ API.
    attr_accessor :base_url

    # URL for the compact CSV format of instruments.
    # @return [String] URL for compact CSV.
    attr_accessor :compact_csv_url

    # URL for the detailed CSV format of instruments.
    # @return [String] URL for detailed CSV.
    attr_accessor :detailed_csv_url

    # Initializes a new configuration instance with default values.
    #
    # @example
    #   config = DhanHQ::Configuration.new
    #   config.client_id = "your_client_id"
    #   config.access_token = "your_access_token"
    def initialize
      @client_id = ENV.fetch("CLIENT_ID", nil)
      @access_token = ENV.fetch("ACCESS_TOKEN", nil)
      @base_url     = "https://api.dhan.co/v2"
    end
  end
end


# File: lib/DhanHQ/constants.rb
# frozen_string_literal: true

module DhanHQ
  module Constants
    TRANSACTION_TYPES = %w[BUY SELL].freeze

    EXCHANGE_SEGMENTS = %w[
      NSE_EQ
      NSE_FNO
      NSE_CURRENCY
      BSE_EQ
      BSE_FNO
      BSE_CURRENCY
      MCX_COMM
      IDX_I
    ].freeze

    INSTRUMENTS = %w[
      INDEX
      FUTIDX
      OPTIDX
      EQUITY
      FUTSTK
      OPTSTK
      FUTCOM
      OPTFUT
      FUTCUR
      OPTCUR
    ].freeze

    PRODUCT_TYPES = %w[
      CNC
      INTRADAY
      MARGIN
      MTF
      CO
      BO
    ].freeze

    ORDER_TYPES = %w[
      LIMIT
      MARKET
      STOP_LOSS
      STOP_LOSS_MARKET
    ].freeze

    VALIDITY_TYPES = %w[DAY IOC].freeze

    AMO_TIMINGS = %w[
      OPEN
      OPEN_30
      OPEN_60
      PRE_OPEN
    ].freeze

    ORDER_STATUSES = %w[
      TRANSIT
      PENDING
      REJECTED
      CANCELLED
      PART_TRADED
      TRADED
      EXPIRED
      MODIFIED
      TRIGGERED
    ].freeze

    # Constants for Exchange Segment
    NSE = "NSE_EQ"
    BSE = "BSE_EQ"
    CUR = "NSE_CURRENCY"
    MCX = "MCX_COMM"
    FNO = "NSE_FNO"
    NSE_FNO = "NSE_FNO"
    BSE_FNO = "BSE_FNO"
    INDEX = "IDX_I"

    OPTION_SEGMENTS = [NSE, BSE, CUR, MCX, FNO, NSE_FNO, BSE_FNO, INDEX].freeze

    # Constants for Transaction Type
    BUY = "BUY"
    SELL = "SELL"

    # Constants for Product Type
    CNC = "CNC"
    INTRA = "INTRADAY"
    MARGIN = "MARGIN"
    CO = "CO"
    BO = "BO"
    MTF = "MTF"

    # Constants for Order Type
    LIMIT = "LIMIT"
    MARKET = "MARKET"
    SL = "STOP_LOSS"
    SLM = "STOP_LOSS_MARKET"

    # Constants for Validity
    DAY = "DAY"
    IOC = "IOC"

    # CSV URLs for Security ID List
    COMPACT_CSV_URL = "https://images.dhan.co/api-data/api-scrip-master.csv"
    DETAILED_CSV_URL = "https://images.dhan.co/api-data/api-scrip-master-detailed.csv"

    # Paths that require `client-id` in headers
    DATA_API_PATHS = %w[
      /v2/marketfeed/ltp
      /v2/marketfeed/ohlc
      /v2/marketfeed/quote
      /v2/optionchain
      /v2/optionchain/expirylist
    ].freeze

    # DHANHQ API Error Mapping
    DHAN_ERROR_MAPPING = {
      "DH-901" => DhanHQ::InvalidAuthenticationError,
      "DH-902" => DhanHQ::InvalidAccessError,
      "DH-903" => DhanHQ::UserAccountError,
      "DH-904" => DhanHQ::RateLimitError,
      "DH-905" => DhanHQ::InputExceptionError,
      "DH-906" => DhanHQ::OrderError,
      "DH-907" => DhanHQ::DataError,
      "DH-908" => DhanHQ::InternalServerError,
      "DH-909" => DhanHQ::NetworkError,
      "DH-910" => DhanHQ::OtherError,
      "800" => DhanHQ::InternalServerError,
      "804" => DhanHQ::Error, # Too many instruments
      "805" => DhanHQ::RateLimitError, # Too many requests
      "806" => DhanHQ::DataError, # Data API not subscribed
      "807" => DhanHQ::InvalidTokenError, # Token expired
      "808" => DhanHQ::AuthenticationFailedError, # Auth failed
      "809" => DhanHQ::InvalidTokenError, # Invalid token
      "810" => DhanHQ::InvalidClientIDError, # Invalid Client ID
      "811" => DhanHQ::InvalidRequestError,  # Invalid expiry date
      "812" => DhanHQ::InvalidRequestError,  # Invalid date format
      "813" => DhanHQ::InvalidRequestError,  # Invalid security ID
      "814" => DhanHQ::InvalidRequestError # Invalid request
    }.freeze
  end
end


# File: lib/DhanHQ/contracts/base_contract.rb
# frozen_string_literal: true

require "dry-validation"
require_relative "../constants"

module DhanHQ
  module Contracts
    # Base contract that includes shared logic and constants.
    class BaseContract < Dry::Validation::Contract
      # Include constants to make them accessible in all derived contracts
      include DhanHQ::Constants
    end
  end
end


# File: lib/DhanHQ/contracts/historical_data_contract.rb
# frozen_string_literal: true

module DhanHQ
  module Contracts
    class HistoricalDataContract < Dry::Validation::Contract
      include DhanHQ::Constants
      params do
        # Common required fields
        required(:security_id).filled(:string)
        required(:exchange_segment).filled(:string, included_in?: EXCHANGE_SEGMENTS)
        required(:instrument).filled(:string, included_in?: INSTRUMENTS)

        # Date range required for both Daily & Intraday
        required(:from_date).filled(:string, format?: /\A\d{4}-\d{2}-\d{2}\z/)
        required(:to_date).filled(:string, format?: /\A\d{4}-\d{2}-\d{2}\z/)

        # Optional fields
        optional(:expiry_code).maybe(:integer, included_in?: [0, 1, 2])

        # For intraday, the user can supply an "interval"
        # (valid: 1, 5, 15, 25, 60)
        optional(:interval).maybe(:string, included_in?: %w[1 5 15 25 60])
      end
    end
  end
end


# File: lib/DhanHQ/contracts/margin_calculator_contract.rb
# frozen_string_literal: true

module DhanHQ
  module Contracts
    class MarginCalculatorContract < Dry::Validation::Contract
      params do
        required(:dhanClientId).filled(:string)
        required(:exchangeSegment).filled(:string, included_in?: %w[NSE_EQ NSE_FNO BSE_EQ])
        required(:transactionType).filled(:string, included_in?: %w[BUY SELL])
        required(:quantity).filled(:integer, gt?: 0)
        required(:productType).filled(:string, included_in?: %w[CNC INTRADAY MARGIN MTF CO BO])
        required(:securityId).filled(:string)
        required(:price).filled(:float, gt?: 0)
        optional(:triggerPrice).maybe(:float)
      end
    end
  end
end


# File: lib/DhanHQ/contracts/modify_order_contract copy.rb
# frozen_string_literal: true

module DhanHQ
  module Contracts
    # Validation contract for modifying an existing order via Dhanhq's API.
    #
    # This contract validates input parameters for the Modify Order API,
    # ensuring that all required fields are provided and optional fields follow
    # the correct constraints. It also applies custom validation rules based on
    # the type of order.
    #
    # Example usage:
    #   contract = Dhanhq::Contracts::ModifyOrderContract.new
    #   result = contract.call(
    #     dhanClientId: "123456",
    #     orderId: "1001",
    #     orderType: "STOP_LOSS",
    #     legName: "ENTRY_LEG",
    #     quantity: 10,
    #     price: 150.0,
    #     triggerPrice: 140.0,
    #     validity: "DAY"
    #   )
    #   result.success? # => true or false
    #
    # @see https://dhanhq.co/docs/v2/ Dhanhq API Documentation
    class ModifyOrderContract < BaseContract
      # Parameters and validation rules for the Modify Order request.
      #
      # @!attribute [r] orderId
      #   @return [String] Required. Unique identifier for the order to be modified.
      # @!attribute [r] orderType
      #   @return [String] Required. Type of the order.
      #     Must be one of: LIMIT, MARKET, STOP_LOSS, STOP_LOSS_MARKET.
      # @!attribute [r] legName
      #   @return [String] Optional. Leg name for complex orders.
      #     Must be one of: ENTRY_LEG, TARGET_LEG, STOP_LOSS_LEG, NA.
      # @!attribute [r] quantity
      #   @return [Integer] Required. Quantity to be modified, must be greater than 0.
      # @!attribute [r] price
      #   @return [Float] Optional. Price to be modified, must be greater than 0 if provided.
      # @!attribute [r] disclosedQuantity
      #   @return [Integer] Optional. Disclosed quantity, must be >= 0 if provided.
      # @!attribute [r] triggerPrice
      #   @return [Float] Optional. Trigger price for stop-loss orders, must be greater than 0 if provided.
      # @!attribute [r] validity
      #   @return [String] Required. Validity of the order.
      #     Must be one of: DAY, IOC, GTC, GTD.
      params do
        required(:orderId).filled(:string)
        required(:orderType).filled(:string, included_in?: %w[LIMIT MARKET STOP_LOSS STOP_LOSS_MARKET])
        optional(:legName).maybe(:string, included_in?: %w[ENTRY_LEG TARGET_LEG STOP_LOSS_LEG NA])
        required(:quantity).filled(:integer, gt?: 0)
        optional(:price).maybe(:float, gt?: 0)
        optional(:disclosedQuantity).maybe(:integer, gteq?: 0)
        optional(:triggerPrice).maybe(:float, gt?: 0)
        required(:validity).filled(:string, included_in?: %w[DAY IOC GTC GTD])
      end

      # Custom validation to ensure a trigger price is provided for stop-loss orders.
      #
      # @example Invalid stop-loss order:
      #   orderType: "STOP_LOSS", triggerPrice: nil
      #   => Adds failure message "is required for orderType STOP_LOSS or STOP_LOSS_MARKET".
      #
      # @param triggerPrice [Float] The price at which the order will be triggered.
      # @param orderType [String] The type of the order.
      rule(:triggerPrice, :orderType) do
        if values[:orderType].start_with?("STOP_LOSS") && !values[:triggerPrice]
          key(:triggerPrice).failure("is required for orderType STOP_LOSS or STOP_LOSS_MARKET")
        end
      end

      # Custom validation to ensure a leg name is provided for CO or BO order types.
      #
      # @example Invalid CO order:
      #   orderType: "CO", legName: nil
      #   => Adds failure message "is required for orderType CO or BO".
      #
      # @param legName [String] The leg name of the order.
      # @param orderType [String] The type of the order.
      rule(:legName, :orderType) do
        if %w[CO BO].include?(values[:orderType]) && !values[:legName]
          key(:legName).failure("is required for orderType CO or BO")
        end
      end

      # Custom validation to ensure the price is valid if provided.
      #
      # @example Invalid price:
      #   price: 0
      #   => Adds failure message "must be greater than 0 if provided".
      #
      # @param price [Float] The price of the order.
      rule(:price) do
        key(:price).failure("must be greater than 0 if provided") if values[:price].nil? || values[:price] <= 0
      end
    end
  end
end


# File: lib/DhanHQ/contracts/modify_order_contract.rb
# frozen_string_literal: true

module DhanHQ
  module Contracts
    class ModifyOrderContract < Dry::Validation::Contract
      params do
        required(:dhanClientId).filled(:string)
        required(:orderId).filled(:string)
        optional(:orderType).maybe(:string, included_in?: %w[LIMIT MARKET STOP_LOSS STOP_LOSS_MARKET])
        optional(:quantity).maybe(:integer)
        optional(:price).maybe(:float)
        optional(:triggerPrice).maybe(:float)
        optional(:disclosedQuantity).maybe(:integer)
        optional(:validity).maybe(:string, included_in?: %w[DAY IOC])
      end

      rule(:quantity) do
        key.failure("must be provided if modifying quantity") if value.nil? && values[:price].nil?
      end
    end
  end
end


# File: lib/DhanHQ/contracts/option_chain_contract.rb
# frozen_string_literal: true

require_relative "base_contract"

module DhanHQ
  module Contracts
    # **Validation contract for fetching option chain data**
    #
    # Validates request parameters for fetching option chains & expiry lists.
    class OptionChainContract < BaseContract
      params do
        required(:underlying_scrip).filled(:integer) # Security ID
        required(:underlying_seg).filled(:string, included_in?: %w[IDX_I NSE_FNO BSE_FNO MCX_FO])
        required(:expiry).filled(:string)
      end

      rule(:expiry) do
        # Ensure the expiry date is in "YYYY-MM-DD" format
        key.failure("must be in 'YYYY-MM-DD' format") unless value.match?(/^\d{4}-\d{2}-\d{2}$/)

        # Ensure it is a valid date
        begin
          parsed_date = Date.parse(value)
          key.failure("must be a valid date") unless parsed_date.to_s == value
        rescue ArgumentError
          key.failure("is not a valid date")
        end
      end
    end
  end
end


# File: lib/DhanHQ/contracts/order_contract.rb
# frozen_string_literal: true

# lib/dhan_hq/contracts/order_contract.rb
require "dry-validation"

module DhanHQ
  module Contracts
    class OrderContract < BaseContract
      # Common enums from annexure
      TRANSACTION_TYPES = %w[BUY SELL].freeze
      EXCHANGE_SEGMENTS = %w[NSE_EQ NSE_FNO NSE_CURRENCY BSE_EQ MCX_COMM BSE_CURRENCY BSE_FNO].freeze
      PRODUCT_TYPES = %w[CNC INTRADAY MARGIN CO BO].freeze
      ORDER_TYPES = %w[LIMIT MARKET STOP_LOSS STOP_LOSS_MARKET].freeze
      VALIDITY_TYPES = %w[DAY IOC].freeze
      AMO_TIMES = %w[PRE_OPEN OPEN OPEN_30 OPEN_60].freeze

      params do
        # Common required fields
        required(:dhan_client_id).filled(:string)
        required(:transaction_type).filled(:string, included_in?: TRANSACTION_TYPES)
        required(:exchange_segment).filled(:string, included_in?: EXCHANGE_SEGMENTS)
        required(:product_type).filled(:string, included_in?: PRODUCT_TYPES)
        required(:order_type).filled(:string, included_in?: ORDER_TYPES)
        required(:validity).filled(:string, included_in?: VALIDITY_TYPES)
        required(:security_id).filled(:string)
        required(:quantity).filled(:integer, gt?: 0)

        # Optional fields
        optional(:correlation_id).maybe(:string)
        optional(:disclosed_quantity).maybe(:integer, gteq?: 0)
        optional(:price).maybe(:float)
        optional(:trigger_price).maybe(:float)
        optional(:after_market_order).maybe(:bool)
        optional(:amo_time).maybe(:string, included_in?: AMO_TIMES)
        optional(:bo_profit_value).maybe(:float)
        optional(:bo_stop_loss_value).maybe(:float)
        optional(:leg_name).maybe(:string) # For modifications
      end

      # Conditional validation rules
      rule(:price) do
        key.failure("must be present for LIMIT orders") if values[:order_type] == "LIMIT" && !value
      end

      rule(:trigger_price) do
        if %w[STOP_LOSS STOP_LOSS_MARKET].include?(values[:order_type]) && !value
          key.failure("must be present for STOP_LOSS orders")
        end
      end

      rule(:amo_time) do
        key.failure("must be present for after market orders") if values[:after_market_order] == true && !value
      end

      rule(:bo_profit_value, :bo_stop_loss_value) do
        if values[:product_type] == "BO" && (!values[:bo_profit_value] || !values[:bo_stop_loss_value])
          key.failure("both profit and stop loss values required for BO orders")
        end
      end

      rule(:disclosed_quantity) do
        key.failure("cannot exceed 30% of total quantity") if value && value > (values[:quantity] * 0.3)
      end

      # Modification specific rules (when extending)
      rule(:leg_name) do
        if values[:product_type] == "BO" && !%w[ENTRY_LEG TARGET_LEG STOP_LOSS_LEG].include?(value)
          key.failure("invalid leg name for BO order")
        end
      end
    end

    class PlaceOrderContract < OrderContract
      # Additional placement specific rules
      rule(:after_market_order) do
        key.failure("amo_time required for after market orders") if value == true && !values[:amo_time]
      end
    end

    class ModifyOrderContract < OrderContract
      # Modification specific requirements
      params do
        required(:order_id).filled(:string)
        optional(:quantity).maybe(:integer, gt?: 0)
      end

      rule do
        if !values[:price] && !values[:quantity] && !values[:trigger_price]
          key.failure("at least one modification field required")
        end
      end
    end
  end
end


# File: lib/DhanHQ/contracts/place_order_contract.rb
# frozen_string_literal: true

module DhanHQ
  module Contracts
    # Validation contract for placing an order via Dhanhq's API.
    #
    # This contract validates the parameters required to place an order,
    # ensuring the correctness of inputs based on API requirements. It includes:
    # - Mandatory fields for order placement.
    # - Conditional validation for optional fields based on provided values.
    # - Validation of enumerated values using constants for consistency.
    #
    # Example usage:
    #   contract = Dhanhq::Contracts::PlaceOrderContract.new
    #   result = contract.call(
    #     dhanClientId: "123456",
    #     transaction_type: "BUY",
    #     exchange_segment: "NSE_EQ",
    #     product_type: "CNC",
    #     order_type: "LIMIT",
    #     validity: "DAY",
    #     security_id: "1001",
    #     quantity: 10,
    #     price: 150.0
    #   )
    #   result.success? # => true or false
    #
    # @see https://dhanhq.co/docs/v2/ Dhanhq API Documentation
    class PlaceOrderContract < BaseContract
      # Parameters and validation rules for the place order request.
      #
      # @!attribute [r] correlation_id
      #   @return [String] Optional. Identifier for tracking, max length 25 characters.
      # @!attribute [r] transaction_type
      #   @return [String] Required. BUY or SELL.
      # @!attribute [r] exchange_segment
      #   @return [String] Required. Exchange segment for the order.
      #     Must be one of: `EXCHANGE_SEGMENTS`.
      # @!attribute [r] product_type
      #   @return [String] Required. Product type for the order.
      #     Must be one of: `PRODUCT_TYPES`.
      # @!attribute [r] order_type
      #   @return [String] Required. Type of order.
      #     Must be one of: `ORDER_TYPES`.
      # @!attribute [r] validity
      #   @return [String] Required. Validity of the order.
      #     Must be one of: DAY, IOC.
      # @!attribute [r] trading_symbol
      #   @return [String] Optional. Trading symbol of the instrument.
      # @!attribute [r] security_id
      #   @return [String] Required. Security identifier for the order.
      # @!attribute [r] quantity
      #   @return [Integer] Required. Quantity of the order, must be greater than 0.
      # @!attribute [r] disclosed_quantity
      #   @return [Integer] Optional. Disclosed quantity, must be >= 0 if provided.
      # @!attribute [r] price
      #   @return [Float] Optional. Price for the order, must be > 0 if provided.
      # @!attribute [r] trigger_price
      #   @return [Float] Optional. Trigger price for stop-loss orders, must be > 0 if provided.
      # @!attribute [r] after_market_order
      #   @return [Boolean] Optional. Indicates if this is an after-market order.
      # @!attribute [r] amo_time
      #   @return [String] Optional. Time for after-market orders. Must be one of: OPEN, OPEN_30, OPEN_60.
      # @!attribute [r] bo_profit_value
      #   @return [Float] Optional. Profit value for Bracket Orders, must be > 0 if provided.
      # @!attribute [r] bo_stop_loss_value
      #   @return [Float] Optional. Stop-loss value for Bracket Orders, must be > 0 if provided.
      # @!attribute [r] drv_expiry_date
      #   @return [String] Optional. Expiry date for derivative contracts.
      # @!attribute [r] drv_option_type
      #   @return [String] Optional. Option type for derivatives, must be one of: CALL, PUT, NA.
      # @!attribute [r] drv_strike_price
      #   @return [Float] Optional. Strike price for options, must be > 0 if provided.
      params do
        required(:transaction_type).filled(:string, included_in?: TRANSACTION_TYPES)
        required(:exchange_segment).filled(:string, included_in?: EXCHANGE_SEGMENTS)
        required(:product_type).filled(:string, included_in?: PRODUCT_TYPES)
        required(:order_type).filled(:string, included_in?: ORDER_TYPES)
        required(:validity).filled(:string, included_in?: VALIDITY_TYPES)
        required(:security_id).filled(:string)
        required(:quantity).filled(:integer, gt?: 0)
        optional(:disclosed_quantity).maybe(:integer, gteq?: 0)
        optional(:trading_symbol).maybe(:string)
        optional(:correlation_id).maybe(:string, max_size?: 25)
        optional(:price).maybe(:float, gt?: 0)
        optional(:trigger_price).maybe(:float, gt?: 0)
        optional(:after_market_order).maybe(:bool)
        optional(:amo_time).maybe(:string, included_in?: %w[OPEN OPEN_30 OPEN_60])
        optional(:bo_profit_value).maybe(:float, gt?: 0)
        optional(:bo_stop_loss_value).maybe(:float, gt?: 0)
        optional(:drv_expiry_date).maybe(:string)
        optional(:drv_option_type).maybe(:string, included_in?: %w[CALL PUT NA])
        optional(:drv_strike_price).maybe(:float, gt?: 0)
      end

      # Custom validation for trigger price when the order type is STOP_LOSS or STOP_LOSS_MARKET.
      rule(:trigger_price, :order_type) do
        if values[:order_type] =~ /^STOP_LOSS/ && !values[:trigger_price]
          key(:trigger_price).failure("is required for order_type STOP_LOSS or STOP_LOSS_MARKET")
        end
      end

      # Custom validation for AMO time when the order is marked as after-market.
      rule(:after_market_order, :amo_time) do
        if values[:after_market_order] == true && !values[:amo_time]
          key(:amo_time).failure("is required when after_market_order is true")
        end
      end

      # Custom validation for Bracket Order (BO) fields.
      rule(:bo_profit_value, :bo_stop_loss_value, :product_type) do
        if values[:product_type] == "BO" && (!values[:bo_profit_value] || !values[:bo_stop_loss_value])
          key(:bo_profit_value).failure("is required for Bracket Orders")
          key(:bo_stop_loss_value).failure("is required for Bracket Orders")
        end
      end
    end
  end
end


# File: lib/DhanHQ/contracts/slice_order_contract.rb
# frozen_string_literal: true

require_relative "base_contract"

module DhanHQ
  module Contracts
    # Validation contract for slicing an order into multiple parts for Dhanhq's API.
    #
    # This contract ensures all required parameters are provided and optional parameters
    # meet the required constraints when they are specified. It validates:
    # - Required fields for slicing orders.
    # - Conditional logic for fields based on the provided values.
    # - Constraints such as inclusion, numerical ranges, and string formats.
    #
    # Example usage:
    #   contract = Dhanhq::Contracts::SliceOrderContract.new
    #   result = contract.call(
    #     dhanClientId: "123456",
    #     transactionType: "BUY",
    #     exchangeSegment: "NSE_EQ",
    #     productType: "CNC",
    #     orderType: "LIMIT",
    #     validity: "DAY",
    #     securityId: "1001",
    #     quantity: 10
    #   )
    #   result.success? # => true or false
    #
    # @see https://dhanhq.co/docs/v2/ Dhanhq API Documentation
    class SliceOrderContract < BaseContract
      # Parameters and validation rules for the slicing order request.
      #
      # @!attribute [r] correlationId
      #   @return [String] Optional. Identifier for tracking, max length 25 characters.
      # @!attribute [r] transactionType
      #   @return [String] Required. BUY or SELL.
      # @!attribute [r] exchangeSegment
      #   @return [String] Required. The segment in which the order is placed.
      #     Must be one of: NSE_EQ, NSE_FNO, NSE_CURRENCY, BSE_EQ, BSE_FNO, BSE_CURRENCY, MCX_COMM.
      # @!attribute [r] productType
      #   @return [String] Required. Product type for the order.
      #     Must be one of: CNC, INTRADAY, MARGIN, MTF, CO, BO.
      # @!attribute [r] orderType
      #   @return [String] Required. Type of order.
      #     Must be one of: LIMIT, MARKET, STOP_LOSS, STOP_LOSS_MARKET.
      # @!attribute [r] validity
      #   @return [String] Required. Validity of the order.
      #     Must be one of: DAY, IOC, GTC, GTD.
      # @!attribute [r] securityId
      #   @return [String] Required. Security identifier for the order.
      # @!attribute [r] quantity
      #   @return [Integer] Required. Quantity of the order, must be greater than 0.
      # @!attribute [r] disclosedQuantity
      #   @return [Integer] Optional. Disclosed quantity, must be >= 0 if provided.
      # @!attribute [r] price
      #   @return [Float] Optional. Price for the order, must be > 0 if provided.
      # @!attribute [r] triggerPrice
      #   @return [Float] Optional. Trigger price for stop-loss orders, must be > 0 if provided.
      # @!attribute [r] afterMarketOrder
      #   @return [Boolean] Optional. Indicates if this is an after-market order.
      # @!attribute [r] amoTime
      #   @return [String] Optional. Time for after-market orders. Must be one of: OPEN, OPEN_30, OPEN_60.
      # @!attribute [r] boProfitValue
      #   @return [Float] Optional. Profit value for Bracket Orders, must be > 0 if provided.
      # @!attribute [r] boStopLossValue
      #   @return [Float] Optional. Stop-loss value for Bracket Orders, must be > 0 if provided.
      # @!attribute [r] drvExpiryDate
      #   @return [String] Optional. Expiry date for derivative contracts.
      # @!attribute [r] drvOptionType
      #   @return [String] Optional. Option type for derivatives, must be one of: CALL, PUT, NA.
      # @!attribute [r] drvStrikePrice
      #   @return [Float] Optional. Strike price for options, must be > 0 if provided.
      params do
        optional(:correlationId).maybe(:string, max_size?: 25)
        required(:transactionType).filled(:string, included_in?: %w[BUY SELL])
        required(:exchangeSegment).filled(:string,
                                          included_in?: %w[NSE_EQ NSE_FNO NSE_CURRENCY BSE_EQ BSE_FNO BSE_CURRENCY
                                                           MCX_COMM])
        required(:productType).filled(:string, included_in?: %w[CNC INTRADAY MARGIN MTF CO BO])
        required(:orderType).filled(:string, included_in?: %w[LIMIT MARKET STOP_LOSS STOP_LOSS_MARKET])
        required(:validity).filled(:string, included_in?: %w[DAY IOC GTC GTD])
        required(:securityId).filled(:string)
        required(:quantity).filled(:integer, gt?: 0)
        optional(:disclosedQuantity).maybe(:integer, gteq?: 0)
        optional(:price).maybe(:float, gt?: 0)
        optional(:triggerPrice).maybe(:float, gt?: 0)
        optional(:afterMarketOrder).maybe(:bool)
        optional(:amoTime).maybe(:string, included_in?: %w[OPEN OPEN_30 OPEN_60])
        optional(:boProfitValue).maybe(:float, gt?: 0)
        optional(:boStopLossValue).maybe(:float, gt?: 0)
        optional(:drvExpiryDate).maybe(:string)
        optional(:drvOptionType).maybe(:string, included_in?: %w[CALL PUT NA])
        optional(:drvStrikePrice).maybe(:float, gt?: 0)
      end

      # Custom validation for trigger price when the order type is STOP_LOSS or STOP_LOSS_MARKET.
      rule(:triggerPrice, :orderType) do
        if values[:orderType].start_with?("STOP_LOSS") && !values[:triggerPrice]
          key(:triggerPrice).failure("is required for orderType STOP_LOSS or STOP_LOSS_MARKET")
        end
      end

      # Custom validation for AMO time when the order is marked as after-market.
      rule(:afterMarketOrder, :amoTime) do
        if values[:afterMarketOrder] == true && !values[:amoTime]
          key(:amoTime).failure("is required when afterMarketOrder is true")
        end
      end
    end
  end
end


# File: lib/DhanHQ/core/base_api.rb
# frozen_string_literal: true

module DhanHQ
  # Base class for all API resource classes
  # Delegates HTTP requests to `DhanHQ::Client`
  class BaseAPI
    include DhanHQ::APIHelper
    include DhanHQ::AttributeHelper

    API_TYPE = :non_trading_api
    HTTP_PATH = ""

    attr_reader :client

    # Initializes the BaseAPI with the appropriate Client instance
    #
    # @param api_type [Symbol] API type (`:order_api`, `:data_api`, `:non_trading_api`)
    def initialize(api_type: self.class::API_TYPE)
      @client = DhanHQ::Client.new(api_type: api_type)
    end

    # Perform a GET request via `Client`
    #
    # @param endpoint [String] API endpoint
    # @param params [Hash] Query parameters
    # @return [Hash, Array] The parsed API response
    def get(endpoint, params: {})
      formatted_params = format_params(endpoint, params)
      handle_response(client.get(build_path(endpoint), formatted_params))
    end

    # Perform a POST request via `Client`
    #
    # @param endpoint [String] API endpoint
    # @param params [Hash] Request body
    # @return [Hash, Array] The parsed API response
    def post(endpoint, params: {})
      formatted_params = format_params(endpoint, params)
      handle_response(client.post(build_path(endpoint), formatted_params))
    end

    # Perform a PUT request via `Client`
    #
    # @param endpoint [String] API endpoint
    # @param params [Hash] Request body
    # @return [Hash, Array] The parsed API response
    def put(endpoint, params: {})
      formatted_params = format_params(endpoint, params)
      handle_response(client.put(build_path(endpoint), formatted_params))
    end

    # Perform a DELETE request via `Client`
    #
    # @param endpoint [String] API endpoint
    # @return [Hash, Array] The parsed API response
    def delete(endpoint)
      formatted_params = format_params(endpoint, {})
      handle_response(client.delete(build_path(endpoint), formatted_params))
    end

    private

    # Performs an API request.
    #
    # @param method [Symbol] HTTP method (:get, :post, :put, :delete)
    # @param endpoint [String] API endpoint
    # @param params [Hash] Request parameters
    # @return [Hash, Array] The parsed API response
    # @raise [DhanHQ::Error] If an API error occurs.
    def request(method, endpoint, params: {})
      formatted_params = format_params(endpoint, params)

      response = client.request(method, build_path(endpoint), formatted_params)

      handle_response(response)
    end

    # Construct the complete API URL
    #
    # @param endpoint [String] API endpoint
    # @return [String] Full API path
    def build_path(endpoint)
      "#{self.class::HTTP_PATH}#{endpoint}"
    end

    # Format parameters based on API endpoint
    def format_params(endpoint, params)
      return params if marketfeed_api?(endpoint) || params.empty?

      optionchain_api?(endpoint) ? titleize_keys(params) : camelize_keys(params)
    end

    # Determines if the API endpoint is for Option Chain
    def optionchain_api?(endpoint)
      endpoint.include?("/optionchain")
    end

    def marketfeed_api?(endpoint)
      endpoint.include?("/marketfeed")
    end
  end
end


# File: lib/DhanHQ/core/base_model.rb
# frozen_string_literal: true

require "dry-validation"
require "active_support/core_ext/hash/indifferent_access"
require "active_support/inflector"

module DhanHQ
  # Base class for resource objects
  # Handles validation, attribute mapping, and response parsing
  class BaseModel
    # Extend & Include Modules
    extend DhanHQ::APIHelper
    extend DhanHQ::AttributeHelper
    extend DhanHQ::ValidationHelper
    extend DhanHQ::RequestHelper
    extend DhanHQ::ResponseHelper

    include DhanHQ::APIHelper
    include DhanHQ::AttributeHelper
    include DhanHQ::ValidationHelper
    include DhanHQ::RequestHelper
    include DhanHQ::ResponseHelper

    # Attribute Accessors
    attr_reader :attributes, :errors

    # Initialize a new resource object
    #
    # @param attributes [Hash] The attributes of the resource
    def initialize(attributes = {}, skip_validation: false)
      @attributes = normalize_keys(attributes)
      @errors = {}

      validate! unless skip_validation
      assign_attributes
    end

    # Class Methods
    # Attributes set by child classes
    class << self
      attr_reader :defined_attributes

      # Registers the set of attributes for this model
      #
      # @param args [Array<Symbol, String>] A list of attribute names
      def attributes(*args)
        @defined_attributes ||= []
        @defined_attributes.concat(args.map(&:to_s))
      end

      # Provide a default API type, can be overridden by child classes
      #
      # e.g., def self.api_type; :data_api; end
      #
      # or override the `api` method entirely
      def api_type
        :order_api
      end

      # Provide a shared BaseAPI instance for this model
      #
      # For child classes, override `api_type` or `api` if needed
      def api
        @api ||= BaseAPI.new(api_type: api_type)
      end

      ##
      # Returns the API resource used by collection methods.
      #
      # Subclasses may override this to return a specialized API class.
      # By default it simply returns {#api}.
      def resource
        api
      end

      # Retrieve the resource path for the API
      #
      # @return [String] The resource path
      def resource_path
        self::HTTP_PATH
      end

      # Every model must either override this or set a Dry::Validation contract if they need validation
      #
      # @return [Dry::Validation::Contract] The validation contract
      def validation_contract
        raise NotImplementedError, "#{name} must implement `validation_contract`"
      end

      # Validate attributes before creating a new instance
      def validate_attributes(attributes)
        contract = validation_contract
        result = contract.call(attributes)

        raise ArgumentError, "Validation failed: #{result.errors.to_h}" if result.failure?
      end

      # == CRUD / Collection Methods

      # Find all resources
      #
      # @return [Array<DhanHQ::BaseModel>, DhanHQ::ErrorObject] An array of resources or error object
      def all
        response = resource.get(resource_path)

        parse_collection_response(response)
      end

      # Find a resource by ID
      #
      # @param id [String] The ID of the resource
      # @return [DhanHQ::BaseModel, DhanHQ::ErrorObject] The resource or error object
      def find(id)
        response = resource.get("#{resource_path}/#{id}")

        payload = response.is_a?(Array) ? response.first : response
        build_from_response(payload)
      end

      def where(params)
        response = resource.get(resource_path, params)
        self.class.build_from_response(response)
      end

      # Create a new resource
      #
      # @param attributes [Hash] The attributes of the resource
      # @return [DhanHQ::BaseModel, DhanHQ::ErrorObject] The resource or error object
      def create(attributes)
        # validate_params!(attributes, validation_contract)

        response = resource.post(resource_path, params: attributes)
        build_from_response(response)
      end

      # Helper method to parse a collection response into model instances
      #
      # @param response [Object] The raw response from the API
      # @return [Array<BaseModel>]
      def parse_collection_response(response)
        # Some endpoints return arrays, others might return a `[:data]` structure
        return [] unless response.is_a?(Array) || (response.is_a?(Hash) && response[:data].is_a?(Array))

        collection = response.is_a?(Array) ? response : response[:data]
        collection.map { |record| new(record) }
      end
    end

    # Instance Methods

    # Update an existing resource
    #
    # @param attributes [Hash] Attributes to update
    # @return [DhanHQ::BaseModel, DhanHQ::ErrorObject]
    def update(attributes = {})
      response = self.class.resource.put("#{self.class.resource_path}/#{id}", params: attributes)

      success_response?(response) ? self.class.build_from_response(response) : DhanHQ::ErrorObject.new(response)
    end

    def save
      new_record? ? self.class.create(attributes) : update(attributes)
    end

    def save!
      raise DhanHQ::ErrorObject, "Failed to save the record" unless save
    end

    # Delete the resource
    #
    # @return [Boolean] True if deletion was successful
    def delete
      response = self.class.resource.delete("#{self.class.resource_path}/#{id}")
      success_response?(response)
    rescue StandardError
      false
    end

    def destroy
      response = self.class.resource.delete("#{self.class.resource_path}/#{id}")
      success_response?(response)
    rescue StandardError
      false
    end

    def persisted?
      !!id
    end

    def new_record?
      !persisted?
    end

    # Format request parameters before sending to API
    #
    # @return [Hash] The camelCased attributes
    def to_request_params
      optionchain_api? ? titleize_keys(@attributes) : camelize_keys(@attributes)
    end

    def id
      @attributes[:id] || @attributes[:order_id] || @attributes[:security_id]
    end

    # Dynamically assign attributes as methods
    def assign_attributes
      self.class.defined_attributes&.each do |attr|
        instance_variable_set(:"@#{attr}", @attributes[attr])
        define_singleton_method(attr) { instance_variable_get(:"@#{attr}") }
        define_singleton_method(attr.to_s.camelize(:lower)) { instance_variable_get(:"@#{attr}") }
      end
    end

    def optionchain_api?
      self.class.name.include?("OptionChain")
    end

    # Validate attributes using contract
    def valid?
      contract_class = respond_to?(:validation_contract) ? validation_contract : self.class.validation_contract
      return true unless contract_class

      contract = contract_class.is_a?(Class) ? contract_class.new : contract_class
      result = contract.call(@attributes)

      if result.failure?
        @errors = result.errors.to_h
        return false
      end

      true
    end
  end
end


# File: lib/DhanHQ/core/base_resource.rb
# frozen_string_literal: true

module DhanHQ
  class BaseResource < BaseAPI
    def initialize(api_type: self.class::API_TYPE)
      super(api_type: api_type) # rubocop:disable Style/SuperArguments
    end

    def all
      get(self.class::HTTP_PATH)
    end

    def find(id)
      get("#{self.class::HTTP_PATH}/#{id}")
    end

    def create(params)
      post(self.class::HTTP_PATH, params: params)
    end

    def update(id, params)
      put("#{self.class::HTTP_PATH}/#{id}", params: params)
    end

    def delete(id)
      super("#{self.class::HTTP_PATH}/#{id}")
    end
  end
end


# File: lib/DhanHQ/core/error_handler.rb
# frozen_string_literal: true

module DhanHQ
  class ErrorHandler
    def self.handle(error)
      case error
      when Dry::Validation::Result
        raise "Validation Error: #{error.errors.to_h}"
      else
        raise "Error: #{error.message}"
      end
    end
  end
end


# File: lib/DhanHQ/error_object.rb
# frozen_string_literal: true

module DhanHQ
  # Wrapper class for API error responses
  class ErrorObject
    # @return [Hash] Raw error response
    attr_reader :response

    # Initialize a new ErrorObject
    #
    # @param response [Hash] Parsed API response
    def initialize(response)
      @response =
        if response.is_a?(Hash)
          response.with_indifferent_access
        else
          { message: response.to_s }.with_indifferent_access
        end
    end

    # Always returns false to mimic success? interface on resources
    #
    # @return [Boolean]
    def success?
      false
    end

    # Extracts the error message from the response
    #
    # @return [String]
    def message
      response[:errorMessage] || response[:message] || response[:error] || "Unknown error"
    end

    # Error code if present
    #
    # @return [String, nil]
    def code
      response[:errorCode]
    end

    # Alias for the raw response hash
    #
    # @return [Hash]
    def errors
      response
    end
  end
end


# File: lib/DhanHQ/errors.rb
# frozen_string_literal: true

module DhanHQ
  # Base error class for all DhanHQ API errors
  class Error < StandardError; end

  # Authentication and access errors
  # DH-901
  class InvalidAuthenticationError < Error; end
  # DH-902
  class InvalidAccessError < Error; end
  # DH-903
  class UserAccountError < Error; end
  # DH-808
  class AuthenticationFailedError < Error; end
  # DH-807, DH-809
  class InvalidTokenError < Error; end
  # DH-810
  class InvalidClientIDError < Error; end

  # Rate limits and input validation errors
  # DH-904, 805
  class RateLimitError < Error; end
  # DH-905
  class InputExceptionError < Error; end
  # DH-811, DH-812, DH-813, DH-814
  class InvalidRequestError < Error; end

  # Order and market data errors
  class OrderError < Error; end
  class DataError < Error; end

  # Server and network-related errors
  # DH-908, 800
  class InternalServerError < Error; end
  # DH-909
  class NetworkError < Error; end
  # DH-910
  class OtherError < Error; end
  # 404
  class NotFoundError < Error; end
end


# File: lib/DhanHQ/helpers/api_helper.rb
# frozen_string_literal: true

module DhanHQ
  module APIHelper
    def handle_response(response)
      return response if response.is_a?(Array) || response.is_a?(Hash)

      raise DhanHQ::Error, "Unexpected API response format"
    end
  end
end


# File: lib/DhanHQ/helpers/attribute_helper.rb
# frozen_string_literal: true

module DhanHQ
  module AttributeHelper
    # Convert keys from snake_case to camelCase
    #
    # @param hash [Hash] The hash to convert
    # @return [Hash] The camelCased hash
    def camelize_keys(hash)
      hash.transform_keys { |key| key.to_s.camelize(:lower) }
    end

    # Convert keys from snake_case to TitleCase
    #
    # @param hash [Hash] The hash to convert
    # @return [Hash] The TitleCased hash
    def titleize_keys(hash)
      hash.transform_keys { |key| key.to_s.titleize.delete(" ") }
    end

    # Convert keys from camelCase to snake_case
    #
    # @param key [String] The key to convert
    # @return [Symbol] The snake_cased key
    def snake_case(hash)
      hash.transform_keys { |key| key.to_s.underscore.to_sym }
    end

    # Normalize attribute keys to be accessible as both snake_case and camelCase
    #
    # @param hash [Hash] The attributes hash
    # @return [HashWithIndifferentAccess] The normalized attributes
    def normalize_keys(hash)
      hash.each_with_object({}) do |(key, value), result|
        string_key = key.to_s
        result[string_key] = value
        result[string_key.underscore] = value
      end.with_indifferent_access
    end

    # Override `inspect` to display instance variables instead of attributes hash
    #
    # @return [String] Readable debug output for the object
    def inspect
      instance_vars = self.class.defined_attributes.map { |attr| "#{attr}: #{instance_variable_get(:"@#{attr}")}" }
      "#<#{self.class.name} #{instance_vars.join(", ")}>"
    end

    # def format_params(path, params)
    #   return params unless params.is_a?(Hash)

    #   if optionchain_api?(path)
    #     titleize_keys(params)
    #   else
    #     camelize_keys(params)
    #   end
    # end

    # def camelize_keys(hash)
    #   hash.transform_keys { |key| key.to_s.camelize(:lower) }
    # end

    # def titleize_keys(hash)
    #   hash.transform_keys { |key| key.to_s.titleize.delete(" ") }
    # end

    # def optionchain_api?(path)
    #   path.include?("/optionchain")
    # end
  end
end


# File: lib/DhanHQ/helpers/model_helper.rb
# frozen_string_literal: true

module DhanHQ
  module ModelHelper
  end
end


# File: lib/DhanHQ/helpers/request_helper.rb
# frozen_string_literal: true

module DhanHQ
  module RequestHelper
    # Builds a model object from API response
    #
    # @param response [Hash] API response
    # @return [DhanHQ::BaseModel, DhanHQ::ErrorObject]
    def build_from_response(response)
      return DhanHQ::ErrorObject.new(response) unless success_response?(response)

      attributes = if response.is_a?(Hash) && response[:data].is_a?(Hash)
                     response[:data]
                   else
                     response
                   end

      new(attributes, skip_validation: true)
    end

    private

    # Dynamically builds headers for each request.
    #
    # @param path [String] The API endpoint path.
    # @return [Hash] The request headers.
    def build_headers(path)
      headers = {
        "Content-Type" => "application/json",
        "Accept" => "application/json",
        "access-token" => DhanHQ.configuration.access_token
      }

      # Add client-id for DATA APIs
      headers["client-id"] = DhanHQ.configuration.client_id if data_api?(path)

      headers
    end

    # Determines if the API path requires a `client-id` header.
    #
    # @param path [String] The API endpoint path.
    # @return [Boolean] True if the path belongs to a DATA API.
    def data_api?(path)
      DhanHQ::Constants::DATA_API_PATHS.include?(path)
    end

    # Prepares the request payload based on the HTTP method.
    #
    # @param req [Faraday::Request] The request object.
    # @param payload [Hash] The request payload.
    # @param method [Symbol] The HTTP method.
    def prepare_payload(req, payload, method)
      return if payload.nil? || payload.empty?

      unless payload.is_a?(Hash)
        raise DhanHQ::InputExceptionError,
              "Invalid payload: Expected a Hash, got #{payload.class}"
      end

      case method
      when :delete then req.params = {}
      when :get then req.params = payload
      else req.body = payload.to_json
      end
    end
  end
end


# File: lib/DhanHQ/helpers/response_helper.rb
# frozen_string_literal: true

module DhanHQ
  module ResponseHelper
    private

    # Determines if the API response indicates success.
    #
    # Treat responses missing a `:status` key but containing
    # an `orderId` or `orderStatus` as successful. This aligns with
    # certain Dhan APIs which return only order details on success.
    #
    # @param response [Hash] Parsed API response
    # @return [Boolean] True when the response signifies success
    def success_response?(response)
      return false unless response.is_a?(Hash)

      return true if response[:status] == "success"
      return true if response[:status].nil? && (response.key?(:orderId) || response.key?(:orderStatus))

      false
    end

    # Handles the API response.
    #
    # @param response [Faraday::Response] The raw response object.
    # @return [HashWithIndifferentAccess, Array<HashWithIndifferentAccess>] The parsed response.
    # @raise [DhanHQ::Error] If an HTTP error occurs.
    def handle_response(response)
      case response.status
      when 200..299 then parse_json(response.body)
      else handle_error(response)
      end
    end

    # Handles standard HTTP errors.
    #
    # @param response [Faraday::Response] The raw response object.
    # @raise [DhanHQ::Error] The specific error based on response status.
    def handle_error(response)
      body = parse_json(response.body)

      error_code = body[:errorCode] || response.status.to_s
      error_message = body[:errorMessage] || body[:message] || "Unknown error"

      error_class = DhanHQ::Constants::DHAN_ERROR_MAPPING[error_code]

      error_class ||=
        case response.status
        when 400 then DhanHQ::InputExceptionError
        when 401 then DhanHQ::InvalidAuthenticationError
        when 403 then DhanHQ::InvalidAccessError
        when 404 then DhanHQ::NotFoundError
        when 429 then DhanHQ::RateLimitError
        when 500..599 then DhanHQ::InternalServerError
        else DhanHQ::OtherError
        end

      raise error_class, "#{error_code}: #{error_message}"
    end

    # Parses JSON response safely. Converts response body to a hash or array with indifferent access.
    #
    # @param body [String, Hash] The response body.
    # @return [HashWithIndifferentAccess, Array<HashWithIndifferentAccess>] The parsed JSON.
    def parse_json(body)
      parsed_body =
        if body.is_a?(String)
          begin
            JSON.parse(body, symbolize_names: true)
          rescue JSON::ParserError
            {} # Return an empty hash if the string is not valid JSON
          end
        else
          body
        end

      if parsed_body.is_a?(Hash)
        parsed_body.with_indifferent_access
      elsif parsed_body.is_a?(Array)
        parsed_body.map(&:with_indifferent_access)
      else
        parsed_body
      end
    end
  end
end


# File: lib/DhanHQ/helpers/validation_helper.rb
# frozen_string_literal: true

module DhanHQ
  module ValidationHelper
    # Validate the attributes using the validation contract
    #
    # @param params [Hash] The parameters to validate
    # @param contract_class [Class] The contract class to use for validation
    def validate_params!(params, contract_class)
      contract = contract_class.new
      result = contract.call(params)

      raise DhanHQ::Error, "Validation Error: #{result.errors.to_h}" unless result.success?
    end

    # Validate instance attributes using the defined validation contract
    def validate!
      contract_class = respond_to?(:validation_contract) ? validation_contract : self.class.validation_contract
      return unless contract_class

      contract = contract_class.is_a?(Class) ? contract_class.new : contract_class

      result = contract.call(@attributes)
      @errors = result.errors.to_h unless result.success?
      raise DhanHQ::Error, "Validation Error: #{@errors}" unless valid?
    end

    # Checks if the current instance is valid
    #
    # @return [Boolean] True if the model is valid
    def valid?
      @errors.empty?
    end
  end
end


# File: lib/DhanHQ/json_loader.rb
# frozen_string_literal: true

require "json"

module DhanHQ
  module JSONLoader
    def self.load(file)
      file_path = File.expand_path("requests/#{file}", __dir__)
      JSON.parse(File.read(file_path), symbolize_names: true)
    rescue Errno::ENOENT
      puts "File not found: #{file_path}"
      {}
    rescue JSON::ParserError
      puts "Invalid JSON format in #{file_path}"
      {}
    end
  end
end


# File: lib/DhanHQ/models/forever_order.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    class ForeverOrder < BaseModel
      attributes :dhan_client_id, :order_id, :correlation_id, :order_status,
                 :transaction_type, :exchange_segment, :product_type, :order_flag,
                 :order_type, :validity, :trading_symbol, :security_id, :quantity,
                 :disclosed_quantity, :price, :trigger_price, :price1,
                 :trigger_price1, :quantity1, :leg_name, :create_time,
                 :update_time, :exchange_time, :drv_expiry_date, :drv_option_type,
                 :drv_strike_price

      class << self
        # Provides a shared instance of the ForeverOrders resource
        #
        # @return [DhanHQ::Resources::ForeverOrders]
        def resource
          @resource ||= DhanHQ::Resources::ForeverOrders.new
        end

        ##
        # Fetch all forever orders
        #
        # @return [Array<ForeverOrder>]
        def all
          response = resource.all
          return [] unless response.is_a?(Array)

          response.map { |o| new(o, skip_validation: true) }
        end

        ##
        # Retrieve a specific forever order
        #
        # @param order_id [String]
        # @return [ForeverOrder, nil]
        def find(order_id)
          response = resource.find(order_id)
          return nil unless response.is_a?(Hash) && response.any?

          new(response, skip_validation: true)
        end

        ##
        # Create a new forever order
        #
        # @param params [Hash]
        # @return [ForeverOrder, nil]
        def create(params)
          response = resource.create(params)
          return nil unless response.is_a?(Hash) && response["orderId"]

          find(response["orderId"])
        end
      end

      ##
      # Modify an existing forever order
      #
      # @param new_params [Hash]
      # @return [ForeverOrder, nil]
      def modify(new_params)
        raise "Order ID is required to modify a forever order" unless id

        response = self.class.resource.update(id, new_params)
        return self.class.find(id) if self.class.send(:success_response?, response)

        nil
      end

      ##
      # Cancel the forever order
      #
      # @return [Boolean]
      def cancel
        raise "Order ID is required to cancel a forever order" unless id

        response = self.class.resource.cancel(id)
        response["orderStatus"] == "CANCELLED"
      end
    end
  end
end


# File: lib/DhanHQ/models/funds.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    class Funds < BaseModel
      HTTP_PATH = "/v2/fundlimit"

      attributes :available_balance, :sod_limit, :collateral_amount, :receiveable_amount, :utilized_amount,
                 :blocked_payout_amount, :withdrawable_balance

      # The API currently returns the key `availabelBalance` (note the typo).
      # To maintain backwards compatibility while exposing a correctly
      # spelled attribute, map the API response to `available_balance`.
      def assign_attributes
        if @attributes.key?(:availabel_balance) && !@attributes.key?(:available_balance)
          @attributes[:available_balance] = @attributes[:availabel_balance]
        end
        super
      end
      class << self
        ##
        # Provides a **shared instance** of the `Funds` resource.
        #
        # @return [DhanHQ::Resources::Funds]
        def resource
          @resource ||= DhanHQ::Resources::Funds.new
        end

        ##
        # Fetch fund details.
        #
        # @return [Fund]
        def fetch
          response = resource.fetch
          new(response, skip_validation: true)
        end

        ##
        # Fetch only the available balance.
        #
        # @return [Float] Available balance in the trading account.
        def balance
          fetch.available_balance
        end
      end
    end
  end
end


# File: lib/DhanHQ/models/historical_data.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    ##
    # Model class for fetching Daily & Intraday data
    # The default response is a Hash with arrays of "open", "high", "low", etc.
    #
    class HistoricalData < BaseModel
      # Typically, we won't define a single resource path,
      # because we call "daily" or "intraday" endpoints specifically.
      # So let's rely on the resource call directly.
      HTTP_PATH = "/v2/charts"

      # If you want typed attributes, you could define them,
      # but the endpoints return arrays. We'll keep it raw.
      # e.g. attributes :open, :high, :low, :close, :volume, :timestamp

      class << self
        ##
        # Provide a **shared instance** of the `HistoricalData` resource
        #
        # @return [DhanHQ::Resources::HistoricalData]
        def resource
          @resource ||= DhanHQ::Resources::HistoricalData.new
        end

        ##
        # Daily historical data
        # @param params [Hash] The request parameters, e.g.:
        #   {
        #     security_id: "1333",
        #     exchange_segment: "NSE_EQ",
        #     instrument: "EQUITY",
        #     expiry_code: 0,
        #     from_date: "2022-01-08",
        #     to_date: "2022-02-08"
        #   }
        # @return [HashWithIndifferentAccess]
        #   {
        #     open: [...], high: [...], low: [...], close: [...],
        #     volume: [...], timestamp: [...]
        #   }
        def daily(params)
          validate_params!(params, DhanHQ::Contracts::HistoricalDataContract)
          # You can rename the keys from snake_case to something if needed
          resource.daily(params)
          # return as a raw hash or transform further
        end

        ##
        # Intraday historical data
        # @param params [Hash], e.g.:
        #   {
        #     security_id: "1333",
        #     exchange_segment: "NSE_EQ",
        #     instrument: "EQUITY",
        #     interval: "15",
        #     from_date: "2024-09-11",
        #     to_date: "2024-09-15"
        #   }
        # @return [HashWithIndifferentAccess]
        #   { open: [...], high: [...], low: [...], close: [...],
        #     volume: [...], timestamp: [...] }
        def intraday(params)
          validate_params!(params, DhanHQ::Contracts::HistoricalDataContract)
          resource.intraday(params)
        end
      end

      # For a read-only type of data, we might skip validations or specify a contract if needed
      def validation_contract
        nil
      end
    end
  end
end


# File: lib/DhanHQ/models/holding.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    class Holding < BaseModel
      HTTP_PATH = "/v2/holdings"

      attributes :exchange, :trading_symbol, :security_id, :isin, :total_qty,
                 :dp_qty, :t1_qty, :available_qty, :collateral_qty, :avg_cost_price

      class << self
        ##
        # Provides a **shared instance** of the `Holdings` resource.
        #
        # @return [DhanHQ::Resources::Holdings]
        def resource
          @resource ||= DhanHQ::Resources::Holdings.new
        end

        ##
        # Fetch all holdings.
        #
        # @return [Array<Holding>]
        def all
          response = resource.all
          return [] unless response.is_a?(Array)

          response.map { |holding| new(holding, skip_validation: true) }
        end
      end

      ##
      # Convert model attributes to a hash.
      #
      # @return [Hash] Hash representation of the Holding model.
      def to_h
        {
          exchange: exchange,
          trading_symbol: trading_symbol,
          security_id: security_id,
          isin: isin,
          total_qty: total_qty,
          dp_qty: dp_qty,
          t1_qty: t1_qty,
          available_qty: available_qty,
          collateral_qty: collateral_qty,
          avg_cost_price: avg_cost_price
        }
      end
    end
  end
end


# File: lib/DhanHQ/models/ledger_entry.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    ##
    # Represents a single row/entry in the Ledger.
    # Ledger data typically returns an array of these objects.
    class LedgerEntry < BaseModel
      # The endpoint is /v2/ledger?from-date=...&to-date=...
      # So we may define a resource path or rely on the Statements resource.
      HTTP_PATH = "/v2/ledger"

      # Typical fields from API docs
      attributes :dhan_client_id, :narration, :voucherdate, :exchange,
                 :voucherdesc, :vouchernumber, :debit, :credit, :runbal

      class << self
        ##
        # Provides a **shared instance** of the `Statements` resource.
        #
        # @return [DhanHQ::Resources::Statements]
        def resource
          @resource ||= DhanHQ::Resources::Statements.new
        end

        ##
        # Fetch ledger entries for the given date range.
        #
        # @param from_date [String] e.g. "2023-01-01"
        # @param to_date   [String] e.g. "2023-01-31"
        # @return [Array<LedgerEntry>]
        def all(from_date:, to_date:)
          # The resource call returns an Array<Hash>, according to the docs.
          response = resource.ledger(from_date: from_date, to_date: to_date)

          return [] unless response.is_a?(Array)

          response.map do |entry|
            new(entry, skip_validation: true)
          end
        end
      end

      # Optional: you can override #to_h or #inspect if you want a custom representation
      def to_h
        {
          dhan_client_id: dhan_client_id,
          narration: narration,
          voucherdate: voucherdate,
          exchange: exchange,
          voucherdesc: voucherdesc,
          vouchernumber: vouchernumber,
          debit: debit,
          credit: credit,
          runbal: runbal
        }
      end
    end
  end
end


# File: lib/DhanHQ/models/margin.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    class Margin < BaseModel
      HTTP_PATH = "/v2/margincalculator"

      attr_reader :total_margin, :span_margin, :exposure_margin, :available_balance,
                  :variable_margin, :insufficient_balance, :brokerage, :leverage

      class << self
        ##
        # Provides a **shared instance** of the `MarginCalculator` resource.
        #
        # @return [DhanHQ::Resources::MarginCalculator]
        def resource
          @resource ||= DhanHQ::Resources::MarginCalculator.new
        end

        ##
        # Calculate margin requirements for an order.
        #
        # @param params [Hash] Request parameters for margin calculation.
        # @return [Margin]
        def calculate(params)
          response = resource.calculate(params)
          new(response, skip_validation: true)
        end
      end

      ##
      # Convert model attributes to a hash.
      #
      # @return [Hash] Hash representation of the Margin model.
      def to_h
        {
          total_margin: total_margin,
          span_margin: span_margin,
          exposure_margin: exposure_margin,
          available_balance: available_balance,
          variable_margin: variable_margin,
          insufficient_balance: insufficient_balance,
          brokerage: brokerage,
          leverage: leverage
        }
      end
    end
  end
end


# File: lib/DhanHQ/models/market_feed.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    class MarketFeed < BaseModel
      class << self
        def ltp(params)
          resource.ltp(params)
        end

        def ohlc(params)
          resource.ohlc(params)
        end

        def quote(params)
          resource.quote(params)
        end

        def resource
          @resource ||= DhanHQ::Resources::MarketFeed.new
        end
      end
    end
  end
end


# File: lib/DhanHQ/models/option_chain.rb
# frozen_string_literal: true

require_relative "../contracts/option_chain_contract"

module DhanHQ
  module Models
    class OptionChain < BaseModel
      attr_reader :underlying_scrip, :underlying_seg, :expiry, :last_price, :option_data

      class << self
        def resource
          @resource ||= DhanHQ::Resources::OptionChain.new
        end

        # Fetch the entire option chain for an instrument
        #
        # @param params [Hash] The request parameters (snake_case format)
        # @return [HashWithIndifferentAccess] The filtered option chain data
        def fetch(params)
          validate_params!(params, DhanHQ::Contracts::OptionChainContract)

          response = resource.fetch(params)
          return {}.with_indifferent_access unless response[:status] == "success"

          filter_valid_strikes(response[:data]).with_indifferent_access
        end

        # Fetch the expiry list of an underlying security
        #
        # @param params [Hash] The request parameters (snake_case format)
        # @return [Array<String>] The list of expiry dates
        def fetch_expiry_list(params)
          response = resource.expirylist(params)
          response[:status] == "success" ? response[:data] : []
        end

        private

        # **Filters valid strikes where `ce` or `pe` has `last_price > 0` and keeps strike prices as-is**
        #
        # @param data [Hash] The API response data
        # @return [Hash] The filtered option chain data with original strike price keys
        def filter_valid_strikes(data)
          return {} unless data.is_a?(Hash) && data.key?(:oc)

          filtered_oc = data[:oc].each_with_object({}) do |(strike_price, strike_data), result|
            ce_last_price = strike_data.dig("ce", "last_price").to_f
            pe_last_price = strike_data.dig("pe", "last_price").to_f

            # Only keep strikes where at least one of CE or PE has a valid last_price
            result[strike_price] = strike_data if ce_last_price.positive? || pe_last_price.positive?
          end

          data.merge(oc: filtered_oc)
        end

        # Validation contract for option chain
        #
        # @return [DhanHQ::Contracts::OptionChainContract]
        def validation_contract
          DhanHQ::Contracts::OptionChainContract.new
        end
      end

      private

      # Validation contract for option chain
      #
      # @return [DhanHQ::Contracts::OptionChainContract]
      def validation_contract
        DhanHQ::Contracts::OptionChainContract.new
      end
    end
  end
end


# File: lib/DhanHQ/models/order.rb
# frozen_string_literal: true

require_relative "../contracts/place_order_contract"
require_relative "../contracts/modify_order_contract"

module DhanHQ
  module Models
    class Order < BaseModel
      attr_reader :order_id, :order_status

      # Define attributes that are part of an order
      attributes :dhan_client_id, :order_id, :correlation_id, :order_status,
                 :transaction_type, :exchange_segment, :product_type, :order_type,
                 :validity, :trading_symbol, :security_id, :quantity,
                 :disclosed_quantity, :price, :trigger_price, :after_market_order,
                 :bo_profit_value, :bo_stop_loss_value, :leg_name, :create_time,
                 :update_time, :exchange_time, :drv_expiry_date, :drv_option_type,
                 :drv_strike_price, :oms_error_code, :oms_error_description, :algo_id,
                 :remaining_quantity, :average_traded_price, :filled_qty

      class << self
        ##
        # Provides a **shared instance** of the `Orders` resource
        #
        # @return [DhanHQ::Resources::Orders]
        def resource
          @resource ||= DhanHQ::Resources::Orders.new
        end

        ##
        # Fetch all orders for the day.
        #
        # @return [Array<Order>]
        def all
          response = resource.all
          return [] unless response.is_a?(Array)

          response.map { |order| new(order, skip_validation: true) }
        end

        ##
        # Fetch a specific order by ID.
        #
        # @param order_id [String]
        # @return [Order, nil]
        def find(order_id)
          response = resource.find(order_id)
          return nil unless response.is_a?(Hash) || (response.is_a?(Array) && response.any?)

          order_data = response.is_a?(Array) ? response.first : response
          new(order_data, skip_validation: true)
        end

        ##
        # Fetch a specific order by correlation ID.
        #
        # @param correlation_id [String]
        # @return [Order, nil]
        def find_by_correlation(correlation_id)
          response = resource.by_correlation(correlation_id)
          return nil unless response[:status] == "success"

          new(response, skip_validation: true)
        end

        # Place a new order
        #
        # @param params [Hash] Order parameters
        # @return [Order]
        def place(params)
          validate_params!(params, DhanHQ::Contracts::PlaceOrderContract)

          response = resource.place_order(params)
          return nil unless response.is_a?(Hash) && response["orderId"]

          # Fetch the complete order details
          find(response["orderId"])
        end

        ##
        # AR-like create: new => valid? => save => resource.create
        # But we can also define a class method if we want direct:
        #   Order.create(order_params)
        #
        # For the typical usage "Order.new(...).save", we rely on #save below.
        def create(params)
          order = new(params) # build it
          return order unless order.valid? # run place order contract?

          order.save # calls resource create or update
          order
        end
      end

      # Modify the order while preserving existing attributes
      #
      # @param new_params [Hash]
      # @return [Order, nil]
      def modify(new_params)
        raise "Order ID is required to modify an order" unless id

        # Merge current order attributes with new parameters
        updated_params = attributes.merge(new_params)

        # Validate with ModifyOrderContract
        validate_params!(updated_params, DhanHQ::Contracts::ModifyOrderContract)

        # response = self.class.api.put("#{self.class.resource_path}/#{id}", params: attributes)
        update(attributes)
        # Fetch the latest order details
        return self.class.find(id) if response[:orderStatus] == "TRANSIT"

        nil
      end

      # Cancel the order
      #
      # @return [Boolean]
      def cancel
        raise "Order ID is required to cancel an order" unless id

        response = self.class.resource.cancel_order(id)
        response["orderStatus"] == "CANCELLED"
      end

      # Fetch the latest details of the order
      #
      # @return [Order, nil]
      def refresh
        raise "Order ID is required to refresh an order" unless id

        self.class.find(id)
      end

      ##
      # This is how we figure out if it's an existing record or not:
      def new_record?
        order_id.nil? || order_id.to_s.empty?
      end

      ##
      # The ID used for resource calls
      def id
        order_id
      end

      ##
      # Save: If new_record?, do resource.create
      # else resource.update
      def save
        return false unless valid?

        if new_record?
          # PLACE ORDER
          response = self.class.resource.create(to_request_params)
          if success_response?(response) && response["orderId"]
            @attributes.merge!(normalize_keys(response))
            assign_attributes
            true
          else
            # maybe store errors?
            false
          end
        else
          # MODIFY ORDER
          response = self.class.resource.update(id, to_request_params)
          if success_response?(response) && response["orderStatus"]
            @attributes.merge!(normalize_keys(response))
            assign_attributes
            true
          else
            false
          end
        end
      end

      ##
      # Cancel => calls resource.delete
      def destroy
        return false if new_record?

        response = self.class.resource.delete(id)
        if success_response?(response) && response["orderStatus"] == "CANCELLED"
          @attributes[:order_status] = "CANCELLED"
          true
        else
          false
        end
      end
      alias delete destroy

      ##
      # Slicing (optional)
      # If you want an AR approach:
      def slice_order(params)
        self.class.resource.slicing(params.merge(order_id: id))
      end

      ##
      # Because we have two separate contracts: place vs. modify
      # We can do something like:
      def validation_contract
        new_record? ? DhanHQ::Contracts::PlaceOrderContract.new : DhanHQ::Contracts::ModifyOrderContract.new
      end
    end
  end
end


# File: lib/DhanHQ/models/position.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    class Position < BaseModel
      HTTP_PATH = "/v2/positions"

      attributes :dhan_client_id, :trading_symbol, :security_id, :position_type, :exchange_segment,
                 :product_type, :buy_avg, :buy_qty, :cost_price, :sell_avg, :sell_qty,
                 :net_qty, :realized_profit, :unrealized_profit, :rbi_reference_rate, :multiplier,
                 :carry_forward_buy_qty, :carry_forward_sell_qty, :carry_forward_buy_value,
                 :carry_forward_sell_value, :day_buy_qty, :day_sell_qty, :day_buy_value,
                 :day_sell_value, :drv_expiry_date, :drv_option_type, :drv_strike_price,
                 :cross_currency

      class << self
        ##
        # Provides a **shared instance** of the `Positions` resource.
        #
        # @return [DhanHQ::Resources::Positions]
        def resource
          @resource ||= DhanHQ::Resources::Positions.new
        end

        ##
        # Fetch all positions for the day.
        #
        # @return [Array<Position>]
        def all
          response = resource.all
          return [] unless response.is_a?(Array)

          response.map do |position|
            new(snake_case(position), skip_validation: true)
          end
        end

        def active
          all.reject { |position| position.position_type == "CLOSED" }
        end

        # Convert an existing position (intraday <-> delivery)
        # @param params [Hash] parameters as required by the API
        # @return [Hash, DhanHQ::ErrorObject]
        def convert(params)
          response = resource.convert(params)
          success_response?(response) ? response : DhanHQ::ErrorObject.new(response)
        end
      end
    end
  end
end


# File: lib/DhanHQ/models/super_order.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    class SuperOrder < BaseModel
      attributes :dhan_client_id, :order_id, :correlation_id, :order_status,
                 :transaction_type, :exchange_segment, :product_type, :order_type,
                 :validity, :trading_symbol, :security_id, :quantity,
                 :remaining_quantity, :ltp, :price, :after_market_order,
                 :leg_name, :exchange_order_id, :create_time, :update_time,
                 :exchange_time, :oms_error_description, :average_traded_price,
                 :filled_qty, :leg_details, :target_price, :stop_loss_price,
                 :trailing_jump

      class << self
        def resource
          @resource ||= DhanHQ::Resources::SuperOrders.new
        end

        def all
          response = resource.all
          return [] unless response.is_a?(Array)

          response.map { |o| new(o, skip_validation: true) }
        end

        def create(params)
          response = resource.create(params)
          return nil unless response.is_a?(Hash) && response["orderId"]

          new(order_id: response["orderId"], order_status: response["orderStatus"], skip_validation: true)
        end
      end

      def modify(new_params)
        raise "Order ID is required to modify a super order" unless id

        response = self.class.resource.update(id, new_params)
        response["orderId"] == id
      end

      def cancel(leg_name = "ENTRY_LEG")
        raise "Order ID is required to cancel a super order" unless id

        response = self.class.resource.cancel(id, leg_name)
        response["orderStatus"] == "CANCELLED"
      end
    end
  end
end


# File: lib/DhanHQ/models/trade.rb
# frozen_string_literal: true

module DhanHQ
  module Models
    ##
    # Represents a single trade.
    # The API docs show an array of trades from GET /v2/trades/{from-date}/{to-date}/{page}
    class Trade < BaseModel
      # No explicit HTTP_PATH if we rely on the statements resource
      # but we can define it if needed
      HTTP_PATH = "/v2/trades"

      attributes :dhan_client_id, :order_id, :exchange_order_id, :exchange_trade_id,
                 :transaction_type, :exchange_segment, :product_type, :order_type,
                 :trading_symbol, :custom_symbol, :security_id, :traded_quantity,
                 :traded_price, :isin, :instrument, :sebi_tax, :stt, :brokerage_charges,
                 :service_tax, :exchange_transaction_charges, :stamp_duty,
                 :create_time, :update_time, :exchange_time, :drv_expiry_date,
                 :drv_option_type, :drv_strike_price

      class << self
        ##
        # Provide a **shared instance** of the `Statements` resource,
        # where we have `trade_history(from_date:, to_date:, page:)`.
        # used for fetching historical trades.
        def resource
          @resource ||= DhanHQ::Resources::Statements.new
        end

        ##
        # Resource for current day tradebook APIs
        def tradebook_resource
          @tradebook_resource ||= DhanHQ::Resources::Trades.new
        end

        ##
        # Fetch trades within the given date range and page.
        # GET /v2/trades/{from-date}/{to-date}/{page}
        #
        # @param from_date [String]
        # @param to_date   [String]
        # @param page      [Integer] Default 0
        # @return [Array<Trade>]
        # Retrieve historical trades
        def history(from_date:, to_date:, page: 0)
          # The resource call returns an Array<Hash>.
          response = resource.trade_history(from_date: from_date, to_date: to_date, page: page)
          return [] unless response.is_a?(Array)

          response.map { |t| new(t, skip_validation: true) }
        end

        alias all history

        # Retrieve current day trades
        def today
          response = tradebook_resource.all
          return [] unless response.is_a?(Array)

          response.map { |t| new(t, skip_validation: true) }
        end

        # Fetch trades for a specific order id for the current day
        def find_by_order_id(order_id)
          response = tradebook_resource.find(order_id)
          return nil unless response.is_a?(Hash) || (response.is_a?(Array) && response.any?)

          data = response.is_a?(Array) ? response.first : response
          new(data, skip_validation: true)
        end
      end

      # If you want custom validations, you'd set a contract or skip for read-only
      def validation_contract
        nil
      end
    end
  end
end


# File: lib/DhanHQ/rate_limiter.rb
# frozen_string_literal: true

require "concurrent"

module DhanHQ
  class RateLimiter
    RATE_LIMITS = {
      order_api: { per_second: 25, per_minute: 250, per_hour: 1000, per_day: 7000 },
      data_api: { per_second: 10, per_minute: 1000, per_hour: 5000, per_day: 10_000 },
      option_chain: { per_second: 1.0 / 3, per_minute: 20, per_hour: 600, per_day: 4800 },
      non_trading_api: { per_second: 20, per_minute: Float::INFINITY, per_hour: Float::INFINITY,
                         per_day: Float::INFINITY }
    }.freeze

    def initialize(api_type)
      @api_type = api_type
      @buckets = Concurrent::Hash.new
      @buckets[:last_request_time] = Time.at(0) if api_type == :option_chain
      initialize_buckets
      start_cleanup_threads
    end

    def throttle!
      if @api_type == :option_chain
        last_request_time = @buckets[:last_request_time]

        sleep_time = 4 - (Time.now - last_request_time)
        if sleep_time.positive?
          puts "Sleeping for #{sleep_time.round(2)} seconds due to option_chain rate limit"
          sleep(sleep_time)
        end

        @buckets[:last_request_time] = Time.now
        return
      end

      loop do
        break if allow_request?

        sleep(0.1)
      end
      record_request
    end

    private

    def initialize_buckets
      RATE_LIMITS[@api_type].each_key do |interval|
        @buckets[interval] = Concurrent::AtomicFixnum.new(0)
      end
    end

    def allow_request?
      RATE_LIMITS[@api_type].all? do |interval, limit|
        @buckets[interval].value < limit
      end
    end

    def record_request
      RATE_LIMITS[@api_type].each_key do |interval|
        @buckets[interval].increment
      end
    end

    def start_cleanup_threads
      Thread.new do
        loop do
          sleep(1)
          @buckets[:per_second].value = 0
        end
      end
      Thread.new do
        loop do
          sleep(60)
          @buckets[:per_minute].value = 0
        end
      end
      Thread.new do
        loop do
          sleep(3600)
          @buckets[:per_hour].value = 0
        end
      end
      Thread.new do
        loop do
          sleep(86_400)
          @buckets[:per_day].value = 0
        end
      end
    end
  end
end


# File: lib/DhanHQ/requests/optionchain/nifty.json
{
  "UnderlyingScrip": 13,
  "UnderlyingSeg": "IDX_I",
  "Expiry": "2025-02-27"
}


# File: lib/DhanHQ/requests/optionchain/nifty_expiries.json
{
  "UnderlyingScrip": 13,
  "UnderlyingSeg": "IDX_I"
}


# File: lib/DhanHQ/requests/orders/create.json


# File: lib/DhanHQ/resources/forever_orders.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class ForeverOrders < BaseAPI
      API_TYPE = :order_api
      HTTP_PATH = "/v2/forever"

      def all
        get("/all")
      end

      def create(params)
        post("/orders", params: params)
      end

      def find(order_id)
        get("/orders/#{order_id}")
      end

      def update(order_id, params)
        put("/orders/#{order_id}", params: params)
      end

      def cancel(order_id)
        delete("/orders/#{order_id}")
      end
    end
  end
end


# File: lib/DhanHQ/resources/funds.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class Funds < BaseAPI
      API_TYPE = :order_api
      HTTP_PATH = "/v2/fundlimit"

      ##
      # Fetch fund limit details.
      #
      # @return [Hash] API response containing fund details.
      def fetch
        get("")
      end
    end
  end
end


# File: lib/DhanHQ/resources/historical_data.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    ##
    # Resource class for fetching Daily & Intraday historical data.
    # Based on the official docs:
    # - POST /v2/charts/historical  (daily timeframe)
    # - POST /v2/charts/intraday   (minute timeframe)
    #
    class HistoricalData < BaseAPI
      API_TYPE = :data_api     # Because we are fetching market data
      HTTP_PATH = "/v2/charts" # The base path for historical endpoints

      ##
      # POST /v2/charts/historical
      # "Daily Historical Data"
      # @param params [Hash]
      # @return [Hash] The parsed API response containing arrays of open, high, low, close, volume, timestamp
      def daily(params)
        post("/historical", params: params)
      end

      ##
      # POST /v2/charts/intraday
      # "Intraday Historical Data"
      # @param params [Hash]
      # @return [Hash] The parsed API response containing arrays for candle data
      def intraday(params)
        post("/intraday", params: params)
      end
    end
  end
end


# File: lib/DhanHQ/resources/holdings.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class Holdings < BaseAPI
      API_TYPE = :order_api
      HTTP_PATH = "/v2/holdings"

      ##
      # Fetch all holdings.
      #
      # @return [Array<Hash>] API response containing holdings data.
      def all
        get("")
      end
    end
  end
end


# File: lib/DhanHQ/resources/margin_calculator.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class MarginCalculator < BaseAPI
      API_TYPE = :order_api
      HTTP_PATH = "/v2/margincalculator"

      ##
      # Calculate margin requirements for an order.
      #
      # @param params [Hash] Request parameters for margin calculation.
      # @return [Hash] API response containing margin details.
      def calculate(params)
        post("", params: params)
      end
    end
  end
end


# File: lib/DhanHQ/resources/market_feed.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class MarketFeed < BaseAPI
      API_TYPE = :data_api
      HTTP_PATH = "/v2"

      ##
      # POST /v2/marketfeed/ltp
      # Returns the LTP (Last Traded Price) of up to 1000 instruments.
      #
      # @param params [Hash] Example:
      #   {
      #     "NSE_EQ": [11536, 3456],
      #     "NSE_FNO": [49081, 49082]
      #   }
      # @return [HashWithIndifferentAccess]
      def ltp(params)
        post("/marketfeed/ltp", params: params)
      end

      ##
      # POST /v2/marketfeed/ohlc
      # Returns open-high-low-close for up to 1000 instruments.
      #
      # @param params [Hash]
      # @return [HashWithIndifferentAccess]
      def ohlc(params)
        post("/marketfeed/ohlc", params: params)
      end

      ##
      # POST /v2/marketfeed/quote
      # Returns market depth, OI, and other details for up to 1000 instruments.
      #
      # @param params [Hash]
      # @return [HashWithIndifferentAccess]
      def quote(params)
        post("/marketfeed/quote", params: params)
      end
    end
  end
end


# File: lib/DhanHQ/resources/option_chain.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class OptionChain < BaseAPI
      API_TYPE = :option_chain
      HTTP_PATH = "/v2/optionchain"

      ##
      # Fetch option chain data based on provided parameters.
      #
      # @param params [Hash] Query parameters for the request.
      # @return [Hash] API response containing option chain data.
      def fetch(params)
        post("", params: params)
      end

      ##
      # Fetch expiry dates list based on provided parameters.
      #
      # @param params [Hash] Query parameters for the request.
      # @return [Hash] API response containing option chain data.
      def expirylist(params)
        post("/expirylist", params: params)
      end
    end
  end
end


# File: lib/DhanHQ/resources/orders.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class Orders < BaseAPI
      API_TYPE = :order_api
      HTTP_PATH = "/v2/orders"

      # Retrieve orders for the day
      def all
        get("")
      end

      def create(params)
        post("", params: params)
      end

      def find(order_id)
        get("/#{order_id}")
      end

      def update(order_id, params)
        put("/#{order_id}", params: params)
      end

      def cancel(order_id)
        delete("/#{order_id}")
      end

      def slicing(params)
        post("/slicing", params: params)
      end

      # Retrieve order by correlation id
      def by_correlation(correlation_id)
        get("/external/#{correlation_id}")
      end
    end
  end
end


# File: lib/DhanHQ/resources/positions.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class Positions < BaseAPI
      API_TYPE = :order_api
      HTTP_PATH = "/v2/positions"

      ##
      # Fetch all open positions for the day.
      #
      # @return [Array<Hash>] API response containing position data.
      def all
        get("")
      end

      # POST /v2/positions/convert
      def convert(params)
        post("/convert", params: params)
      end
    end
  end
end


# File: lib/DhanHQ/resources/statements.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    ##
    # Provides methods to retrieve Ledger and Trade History.
    #
    # GET /v2/ledger?from-date=YYYY-MM-DD&to-date=YYYY-MM-DD
    # GET /v2/trades/{from-date}/{to-date}/{page}
    #
    class Statements < BaseAPI
      API_TYPE = :non_trading_api
      HTTP_PATH = "/v2"

      ##
      # GET /v2/ledger?from-date=YYYY-MM-DD&to-date=YYYY-MM-DD
      # @param from_date [String] e.g. "2023-01-01"
      # @param to_date   [String] e.g. "2023-01-31"
      # @return [Array<Hash>] An array of ledger entries
      def ledger(from_date:, to_date:)
        # Because the docs say "from-date" & "to-date" (with dashes),
        # pass them as snake case or match them exactly:
        get("/ledger", params: { "from-date": from_date, "to-date": to_date })
      end

      ##
      # GET /v2/trades/{from-date}/{to-date}/{page}
      # @param from_date [String]
      # @param to_date   [String]
      # @param page      [Integer] Defaults to 0
      # @return [Array<Hash>] An array of trades
      #
      def trade_history(from_date:, to_date:, page: 0)
        # docs show this path style:
        # /v2/trades/{from-date}/{to-date}/{page}
        get("/trades/#{from_date}/#{to_date}/#{page}")
      end
    end
  end
end


# File: lib/DhanHQ/resources/super_orders.rb
# frozen_string_literal: true

module DhanHQ
  module Resources
    class SuperOrders < BaseAPI
      API_TYPE = :order_api
      HTTP_PATH = "/v2/super/orders"

      def all
        get("")
      end

      def create(params)
        post("", params: params)
      end

      def update(order_id, params)
        put("/#{order_id}", params: params)
      end

      def cancel(order_id, leg_name)
        delete("/#{order_id}/#{leg_name}")
      end
    end
  end
end


# File: lib/DhanHQ/resources/trades.rb
module DhanHQ
  module Resources
    # Provides access to current day trades endpoints
    class Trades < BaseAPI
      API_TYPE = :order_api
      HTTP_PATH = "/v2/trades".freeze

      # GET /v2/trades
      def all
        get("")
      end

      # GET /v2/trades/{order-id}
      def find(order_id)
        get("/#{order_id}")
      end
    end
  end
end


# File: lib/DhanHQ/version.rb
# frozen_string_literal: true

module DhanHQ
  VERSION = "2.0.1"
end


# File: lib/DhanHQ/ws/client.rb
# frozen_string_literal: true

require "concurrent"
require_relative "cmd_bus"
require_relative "sub_state"
require_relative "connection"
require_relative "decoder"
require_relative "segments"
require_relative "registry"

module DhanHQ
  module WS
    class Client
      def initialize(mode: :ticker, url: nil)
        @mode  = mode # :ticker, :quote, :full (adjust to your API)
        @bus   = CmdBus.new
        @state = SubState.new
        @callbacks = Concurrent::Map.new { |h, k| h[k] = [] }
        @started = Concurrent::AtomicBoolean.new(false)

        token = DhanHQ.configuration.access_token or raise "DhanHQ.access_token not set"
        cid   = DhanHQ.configuration.client_id or raise "DhanHQ.client_id not set"
        ver   = (DhanHQ.configuration.respond_to?(:ws_version) && DhanHQ.configuration.ws_version) || 2
        @url  = url || "wss://api-feed.dhan.co?version=#{ver}&token=#{token}&clientId=#{cid}&authType=2"
      end

      # lifecycle
      def start
        return self if @started.true?

        @started.make_true
        @conn = Connection.new(url: @url, mode: @mode, bus: @bus, state: @state) do |binary|
          tick = Decoder.decode(binary)
          emit(:tick, tick) if tick
        end
        Registry.register(self)
        install_at_exit_once!
        @conn.start
        self
      end

      def stop
        return unless @started.true?

        @started.make_false
        @conn&.stop
        Registry.unregister(self)
        emit(:close, true)
        self
      end

      # Manual “disconnect feed now” (sends RequestCode 12)
      def disconnect!
        return self unless @started.true?

        @started.make_false
        @conn&.disconnect!
        Registry.unregister(self)
        emit(:close, true)
        self
      end

      # subscriptions (accept either one or an array)
      def subscribe_one(segment:, security_id:)
        norm = Segments.normalize_instrument(ExchangeSegment: segment, SecurityId: security_id)
        DhanHQ.logger&.info("[DhanHQ::WS] subscribe_one (normalized) -> #{norm}")
        @bus.sub([prune(norm)])
        self
      end

      # [{ExchangeSegment:, SecurityId:}, ...]
      def subscribe_many(list)
        norms = Segments.normalize_instruments(list).map { |i| prune(i) }
        DhanHQ.logger&.info("[DhanHQ::WS] subscribe_many (normalized) -> #{norms}")
        @bus.sub(norms)
        self
      end

      def unsubscribe_one(segment:, security_id:)
        norm = Segments.normalize_instrument(ExchangeSegment: segment, SecurityId: security_id)
        DhanHQ.logger&.info("[DhanHQ::WS] unsubscribe_one (normalized) -> #{norm}")
        @bus.unsub([prune(norm)])
        self
      end

      def unsubscribe_many(list)
        norms = Segments.normalize_instruments(list).map { |i| prune(i) }
        DhanHQ.logger&.info("[DhanHQ::WS] unsubscribe_many (normalized) -> #{norms}")
        @bus.unsub(norms)
        self
      end

      # ensure we only install one at_exit per process
      def self.install_at_exit_hook!
        return if defined?(@_at_exit_installed) && @_at_exit_installed

        @_at_exit_installed = true
        at_exit do
          DhanHQ.logger&.info("[DhanHQ::WS] at_exit: disconnecting all local clients")
          Registry.stop_all
        rescue StandardError => e
          DhanHQ.logger&.debug("[DhanHQ::WS] at_exit error #{e.class}: #{e.message}")
        end
      end

      # events: :tick, :open, :close, :error
      def on(event, &blk)
        @callbacks[event] << blk
        self
      end

      private

      def prune(h) = { ExchangeSegment: h[:ExchangeSegment], SecurityId: h[:SecurityId] }

      def emit(event, payload)
        begin
          @callbacks[event].dup
        rescue StandardError
          []
        end.each { |cb| cb.call(payload) }
      end

      def install_at_exit_once!
        return if defined?(@at_exit_installed) && @at_exit_installed

        @at_exit_installed = true
        at_exit { Registry.stop_all }
      end
    end
  end
end


# File: lib/DhanHQ/ws/cmd_bus.rb
# frozen_string_literal: true

module DhanHQ
  module WS
    class CmdBus
      Command = Struct.new(:op, :payload, keyword_init: true)

      def initialize
        @q = Queue.new
      end

      def sub(list)   = @q.push(Command.new(op: :sub,   payload: list))
      def unsub(list) = @q.push(Command.new(op: :unsub, payload: list))

      def drain
        out = []
        out << @q.pop(true) while true
      rescue ThreadError
        out
      end
    end
  end
end


# File: lib/DhanHQ/ws/connection.rb
# frozen_string_literal: true

require "eventmachine"
require "faye/websocket"
require "json"

module DhanHQ
  module WS
    class Connection
      SUB_CODES   = { ticker: 15, quote: 17, full: 21 }.freeze # adjust if needed
      UNSUB_CODES = { ticker: 16, quote: 18, full: 22 }.freeze

      COOL_OFF_429 = 60  # seconds to cool off on 429
      MAX_BACKOFF  = 90  # cap exponential backoff

      attr_reader :stopping

      def initialize(url:, mode:, bus:, state:, &on_binary)
        @url = url
        @mode = mode
        @bus = bus
        @state = state
        @on_binary = on_binary
        @stop = false
        @stopping = false
        @ws     = nil
        @timer  = nil
        @cooloff_until = nil
        @thr = nil
      end

      def start
        return self if @thr&.alive?

        @thr = Thread.new { loop_run }
        self
      end

      # Hard stop: no graceful packet, just close and never reconnect
      def stop
        @stop = true
        @stopping = true
        if @ws
          begin
            @ws.close
          rescue StandardError
          end
        end
        self
      end

      # Public API: explicit disconnect (send RequestCode 12) and close socket
      # Graceful broker disconnect (RequestCode 12), then no reconnect
      def disconnect!
        @stop = true
        @stopping = true
        begin
          send_disconnect
        rescue StandardError
        ensure
          @ws&.close
        end
        self
      end

      # Is underlying socket open?
      def open?
        @ws && @ws.instance_variable_get(:@driver)&.ready_state == 1
      rescue StandardError
        false
      end

      private

      def loop_run
        backoff = 2.0
        until @stop
          failed = false
          got_429 = false # rubocop:disable Naming/VariableNumber

          # respect any active cool-off window
          sleep (@cooloff_until - Time.now).ceil if @cooloff_until && Time.now < @cooloff_until

          begin
            EM.run do
              @ws = Faye::WebSocket::Client.new(@url, nil, headers: default_headers)

              @ws.on :open do |_|
                DhanHQ.logger&.info("[DhanHQ::WS] open")
                # re-subscribe snapshot on reconnect
                snapshot = @state.snapshot.map do |k|
                  seg, sid = k.split(":")
                  { ExchangeSegment: seg, SecurityId: sid }
                end
                send_sub(snapshot) unless snapshot.empty?
                @timer = EM.add_periodic_timer(0.25) { drain_and_send }
              end

              @ws.on :message do |ev|
                @on_binary&.call(ev.data) # raw frames to decoder
              end

              @ws.on :close do |ev|
                # If we initiated stop/disconnect, DO NOT reconnect regardless of code.
                EM.cancel_timer(@timer) if @timer
                @timer = nil
                msg = "[DhanHQ::WS] close #{ev.code} #{ev.reason}"
                DhanHQ.logger&.warn(msg)

                if @stopping
                  failed = false
                else
                  failed  = (ev.code != 1000)
                  got_429 = ev.reason.to_s.include?("429")
                end
                EM.stop
              end

              @ws.on :error do |ev|
                DhanHQ.logger&.error("[DhanHQ::WS] error #{ev.message}")
                failed = true
              end
            end
          rescue StandardError => e
            DhanHQ.logger&.error("[DhanHQ::WS] crashed #{e.class} #{e.message}")
            failed = true
          ensure
            break if @stop

            if got_429
              @cooloff_until = Time.now + COOL_OFF_429
              DhanHQ.logger&.warn("[DhanHQ::WS] cooling off #{COOL_OFF_429}s due to 429")
            end

            if failed
              # exponential backoff with jitter
              sleep_time = [backoff, MAX_BACKOFF].min
              jitter = rand(0.2 * sleep_time)
              DhanHQ.logger&.warn("[DhanHQ::WS] reconnecting in #{(sleep_time + jitter).round(1)}s")
              sleep(sleep_time + jitter)
              backoff *= 2.0 # rubocop:disable Lint/UselessAssignment
            else
              backoff = 2.0 # reset only after a clean session end
            end
          end
        end
      end

      def default_headers
        { "User-Agent" => "dhanhq-ruby/#{defined?(DhanHQ::VERSION) ? DhanHQ::VERSION : "dev"} Ruby/#{RUBY_VERSION}" }
      end

      def drain_and_send
        cmds = @bus.drain
        return if cmds.empty?

        subs, unsubs = cmds.partition { |c| c.op == :sub }

        unless subs.empty?
          list     = uniq(flatten(subs.map(&:payload)))
          new_only = @state.want_sub(list)
          unless new_only.empty?
            send_sub(new_only)
            @state.mark_subscribed!(new_only)
          end
        end

        return if unsubs.empty?

        list       = uniq(flatten(unsubs.map(&:payload)))
        exist_only = @state.want_unsub(list)
        return if exist_only.empty?

        send_unsub(exist_only)
        @state.mark_unsubscribed!(exist_only)
      end

      def send_sub(list)
        return if list.empty?

        list.each_slice(100) do |chunk|
          payload = { RequestCode: SUB_CODES.fetch(@mode), InstrumentCount: chunk.size, InstrumentList: chunk }
          DhanHQ.logger&.info("[DhanHQ::WS] SUB -> +#{chunk.size} (total=#{list.size})")
          @ws.send(payload.to_json)
        end
      end

      def send_unsub(list)
        return if list.empty?

        list.each_slice(100) do |chunk|
          payload = { RequestCode: UNSUB_CODES.fetch(@mode), InstrumentCount: chunk.size, InstrumentList: chunk }
          DhanHQ.logger&.info("[DhanHQ::WS] UNSUB -> -#{chunk.size} (total=#{list.size})")
          @ws.send(payload.to_json)
        end
      end

      def send_disconnect
        return unless @ws

        payload = { RequestCode: 12 } # per Dhan: Disconnect Feed
        DhanHQ.logger&.info("[DhanHQ::WS] DISCONNECT -> #{payload}")
        @ws.send(payload.to_json)
      rescue StandardError => e
        DhanHQ.logger&.debug("[DhanHQ::WS] send_disconnect error #{e.class}: #{e.message}")
      end

      def flatten(a) = a.flatten

      def uniq(list)
        seen = {}
        list.each_with_object([]) do |i, out|
          k = "#{i[:ExchangeSegment]}:#{i[:SecurityId]}"
          next if seen[k]

          out << i
          seen[k] = true
        end
      end
    end
  end
end


# File: lib/DhanHQ/ws/decoder.rb
# frozen_string_literal: true

require_relative "websocket_packet_parser"
require_relative "segments"

module DhanHQ
  module WS
    class Decoder
      FEED_KIND = {
        2 => :ticker, 4 => :quote, 5 => :oi, 6 => :prev_close, 8 => :full, 50 => :disconnect, 41 => :depth_bid, 51 => :depth_ask
      }.freeze

      def self.decode(binary)
        pkt = WebsocketPacketParser.new(binary).parse
        return nil if pkt.nil? || pkt.empty?

        kind   = FEED_KIND[pkt[:feed_response_code]] || :unknown
        segstr = Segments.from_code(pkt[:exchange_segment])
        sid    = pkt[:security_id].to_s

        # pp pkt
        case kind
        when :ticker
          {
            kind: :ticker, segment: segstr, security_id: sid,
            ltp: pkt[:ltp].to_f, ts: pkt[:ltt].to_i
          }
        when :quote
          {
            kind: :quote, segment: segstr, security_id: sid,
            ltp: pkt[:ltp].to_f, ts: pkt[:ltt].to_i, atp: pkt[:atp].to_f,
            vol: pkt[:volume].to_i, ts_buy_qty: pkt[:total_buy_qty].to_i, ts_sell_qty: pkt[:total_sell_qty].to_i,
            day_open: pkt[:day_open]&.to_f, day_high: pkt[:day_high]&.to_f, day_low: pkt[:day_low]&.to_f, day_close: pkt[:day_close]&.to_f
          }
        when :full
          out = {
            kind: :full, segment: segstr, security_id: sid,
            ltp: pkt[:ltp].to_f, ts: pkt[:ltt].to_i, atp: pkt[:atp].to_f,
            vol: pkt[:volume].to_i, ts_buy_qty: pkt[:total_buy_qty].to_i, ts_sell_qty: pkt[:total_sell_qty].to_i,
            oi: pkt[:open_interest]&.to_i, oi_high: pkt[:highest_open_interest]&.to_i, oi_low: pkt[:lowest_open_interest]&.to_i,
            day_open: pkt[:day_open]&.to_f, day_high: pkt[:day_high]&.to_f, day_low: pkt[:day_low]&.to_f, day_close: pkt[:day_close]&.to_f
          }
          # First depth level (if present)
          if (md = pkt[:market_depth]).respond_to?(:[]) && md[0]
            lvl = md[0]
            out[:bid] = lvl.respond_to?(:bid_price) ? lvl.bid_price.to_f : nil
            out[:ask] = lvl.respond_to?(:ask_price) ? lvl.ask_price.to_f : nil
          end
          out
        when :oi
          { kind: :oi, segment: segstr, security_id: sid, oi: pkt[:open_interest].to_i }
        when :prev_close
          { kind: :prev_close, segment: segstr, security_id: sid, prev_close: pkt[:prev_close].to_f,
            oi_prev: pkt[:oi_prev].to_i }
        when :depth_bid, :depth_ask
          {
            kind: kind, segment: segstr, security_id: sid,
            bid_quantity: pkt[:bid_quantity], ask_quantity: pkt[:ask_quantity],
            no_of_bid_orders: pkt[:no_of_bid_orders], no_of_ask_orders: pkt[:no_of_ask_orders],
            bid: pkt[:bid_price], ask: pkt[:ask_price]
          }
        when :disconnect
          DhanHQ.logger&.warn("[DhanHQ::WS] disconnect code=#{pkt[:disconnection_code]} seg=#{segstr} sid=#{sid}")
          nil
        else
          DhanHQ.logger&.debug("[DhanHQ::WS] unknown feed kind code=#{pkt[:feed_response_code]}")
          nil
        end
      rescue StandardError => e
        DhanHQ.logger&.debug("[DhanHQ::WS::Decoder] #{e.class}: #{e.message}")
        nil
      end
    end
  end
end


# File: lib/DhanHQ/ws/errors.rb


# File: lib/DhanHQ/ws/packets/depth_delta_packet.rb
# frozen_string_literal: true

require "bindata"

module DhanHQ
  module WS
    module Packets
      # Depth delta payload (20 bytes): see Dhan spec
      class DepthDeltaPacket < BinData::Record
        endian :little
        uint32 :bid_quantity        # 4
        uint32 :ask_quantity        # 4
        uint16 :no_of_bid_orders    # 2
        uint16 :no_of_ask_orders    # 2
        float  :bid_price           # 4
        float  :ask_price           # 4
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/disconnect_packet.rb
# frozen_string_literal: true

require "bindata"

module DhanHQ
  module WS
    module Packets
      # Disconnect payload (2 bytes). Your earlier code read signed big-endian; make it explicit.
      class DisconnectPacket < BinData::Record
        endian :big
        uint16 :code
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/full_packet.rb
# lib/dhanhq/ws/packets/full_packet.rb
require "bindata"
require_relative "market_depth_level"
module DhanHQ
  module WS
    module Packets
      class FullPacket < BinData::Record
        endian :little

        # Core Quote Data
        float :ltp # 4 bytes
        uint16 :last_trade_qty          # 2 bytes
        uint32 :ltt                     # 4 bytes (epoch in seconds)
        float :atp                      # 4 bytes
        uint32 :volume                  # 4 bytes
        int32 :total_sell_qty           # 4 bytes
        int32 :total_buy_qty            # 4 bytes

        # Open Interest & Extremes
        int32 :open_interest            # 4 bytes
        int32 :highest_oi               # 4 bytes (optional, F&O only)
        int32 :lowest_oi                # 4 bytes (optional, F&O only)

        # OHLC Values
        float :day_open                 # 4 bytes
        float :day_close                # 4 bytes
        float :day_high                 # 4 bytes
        float :day_low                  # 4 bytes

        # Market Depth (5 levels × 20 bytes)
        array :market_depth, initial_length: 5 do
          market_depth_level
        end
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/header.rb
require "bindata"

module DhanHQ
  module WS
    module Packets
      class Header < BinData::Record
        endian :big # Default to big-endian for majority fields

        uint8  :feed_response_code     # Byte 1
        uint16 :message_length         # Bytes 2–3
        uint8  :exchange_segment       # Byte 4

        # Parse security_id separately using little-endian
        # This works because `BinData` allows override
        int32le :security_id # Bytes 5–8
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/index_packet.rb
# frozen_string_literal: true

module DhanHQ
  module WS
    module Packets
      # Layout not in public docs; keep raw bytes for now
      class IndexPacket
        attr_reader :raw

        def initialize(raw) = (@raw = raw)
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/market_depth_level.rb
# lib/dhanhq/ws/packets/market_depth_level.rb
require "bindata"
module DhanHQ
  module WS
    module Packets
      class MarketDepthLevel < BinData::Record
        endian :little

        uint32 :bid_quantity           # 4 bytes
        uint32 :ask_quantity           # 4 bytes
        uint16 :no_of_bid_orders       # 2 bytes
        uint16 :no_of_ask_orders       # 2 bytes
        float  :bid_price              # 4 bytes
        float  :ask_price              # 4 bytes
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/market_status_packet.rb
# frozen_string_literal: true

module DhanHQ
  module WS
    module Packets
      # Layout not in public docs; keep raw bytes for now
      class MarketStatusPacket
        attr_reader :raw

        def initialize(raw) = (@raw = raw)
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/oi_packet.rb
# frozen_string_literal: true

require "bindata"

module DhanHQ
  module WS
    module Packets
      # OI payload (4 bytes): int32 little-endian
      class OiPacket < BinData::Record
        endian :little
        int32  :open_interest
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/prev_close_packet.rb
# frozen_string_literal: true

require "bindata"

module DhanHQ
  module WS
    module Packets
      # Prev Close payload (8 bytes): float32 prev_close, int32 oi_prev (little-endian)
      class PrevClosePacket < BinData::Record
        endian :little
        float :prev_close    # 4 bytes
        int32 :oi_prev       # 4 bytes
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/quote_packet.rb
# lib/dhanhq/ws/packets/quote_packet.rb
require "bindata"
module DhanHQ
  module WS
    module Packets
      class QuotePacket < BinData::Record
        endian :little

        float  :ltp # 4 bytes
        uint16 :last_trade_qty          # 2 bytes
        uint32 :ltt                     # 4 bytes
        float  :atp                     # 4 bytes
        uint32 :volume                  # 4 bytes
        int32  :total_sell_qty          # 4 bytes
        int32  :total_buy_qty           # 4 bytes
        float  :day_open                # 4 bytes
        float  :day_close               # 4 bytes
        float  :day_high                # 4 bytes
        float  :day_low                 # 4 bytes
      end
    end
  end
end


# File: lib/DhanHQ/ws/packets/ticker_packet.rb
# frozen_string_literal: true

require "bindata"

module DhanHQ
  module WS
    module Packets
      # Ticker payload (8 bytes): float32 ltp, int32 ltt (both little-endian)
      class TickerPacket < BinData::Record
        endian :little
        float  :ltp       # 4 bytes
        int32  :ltt       # 4 bytes
      end
    end
  end
end


# File: lib/DhanHQ/ws/registry.rb
# frozen_string_literal: true

require "concurrent"

# frozen_string_literal: true
module DhanHQ
  module WS
    class Registry
      @clients = []
      class << self
        def register(client)
          @clients << client unless @clients.include?(client)
        end

        def unregister(client)
          @clients.delete(client)
        end

        def stop_all
          @clients.dup.each do |c|
            c.stop
          rescue StandardError
          end
          @clients.clear
        end
      end
    end

    # convenience API
    def self.disconnect_all_local!
      Registry.stop_all
    end
  end
end


# File: lib/DhanHQ/ws/segments.rb
# frozen_string_literal: true

module DhanHQ
  module WS
    module Segments
      # Canonical enum mapping (per Dhan spec)
      STRING_TO_CODE = {
        "IDX_I" => 0,
        "NSE_EQ" => 1,
        "NSE_FNO" => 2,
        "NSE_CURRENCY" => 3,
        "BSE_EQ" => 4,
        "MCX_COMM" => 5,
        "BSE_CURRENCY" => 7,
        "BSE_FNO" => 8
      }.freeze

      CODE_TO_STRING = STRING_TO_CODE.invert.freeze

      # Accept "NSE_FNO"/:nse_fno/2/"2" and return the STRING Dhan expects in requests.
      def self.to_request_string(segment)
        case segment
        when String
          return segment if STRING_TO_CODE.key?(segment) # already canonical
          return CODE_TO_STRING[segment.to_i] if /\A\d+\z/.match?(segment) # "2" -> "NSE_FNO"

          STRING_TO_CODE.key(segment) || segment.upcase # e.g. "nse_fno" -> "NSE_FNO"
        when Symbol
          up = segment.to_s.upcase
          STRING_TO_CODE.key(STRING_TO_CODE[up]) || up
        when Integer
          CODE_TO_STRING[segment] || segment.to_s
        else
          segment.to_s
        end
      end

      # Normalize a single instrument for subscribe/unsubscribe requests.
      # Ensures:
      #   - ExchangeSegment is a STRING enum (e.g., "NSE_FNO")
      #   - SecurityId is a STRING
      def self.normalize_instrument(h)
        seg = to_request_string(h[:ExchangeSegment] || h["ExchangeSegment"])
        sid = (h[:SecurityId] || h["SecurityId"]).to_s
        { ExchangeSegment: seg, SecurityId: sid }
      end

      def self.normalize_instruments(list)
        Array(list).map { |h| normalize_instrument(h) }
      end

      # Convert response header's segment code (byte) -> enum string
      def self.from_code(code_byte)
        CODE_TO_STRING[code_byte] || code_byte.to_s
      end
    end
  end
end


# File: lib/DhanHQ/ws/singleton_lock.rb
# frozen_string_literal: true

require "digest"

module DhanHQ
  module WS
    class SingletonLock
      def initialize(token:, client_id:)
        key = Digest::SHA256.hexdigest("#{client_id}:#{token}")[0, 12]
        @path = File.expand_path("tmp/dhanhq_ws_#{key}.lock", Dir.pwd)
        FileUtils.mkdir_p(File.dirname(@path))
        @fh = File.open(@path, File::RDWR | File::CREAT, 0o644)
      end

      def acquire!
        unless @fh.flock(File::LOCK_NB | File::LOCK_EX)
          pid = begin
            @fh.read.to_i
          rescue StandardError
            nil
          end
          raise "Another DhanHQ WS process is active (pid=#{pid}). Stop it first."
        end
        @fh.rewind
        @fh.truncate(0)
        @fh.write(Process.pid.to_s)
        @fh.flush
        true
      end

      def release!
        @fh.flock(File::LOCK_UN)
        @fh.close
        begin
          File.delete(@path)
        rescue StandardError
          nil
        end
      end
    end
  end
end


# File: lib/DhanHQ/ws/sub_state.rb
# frozen_string_literal: true

require "concurrent"

module DhanHQ
  module WS
    class SubState
      def initialize
        @set   = Concurrent::Set.new
        @mutex = Mutex.new
      end

      def want_sub(list)
        @mutex.synchronize { list.reject { |i| @set.include?(key_for(i)) } }
      end

      def mark_subscribed!(list)
        @mutex.synchronize { list.each { |i| @set.add(key_for(i)) } }
      end

      def want_unsub(list)
        @mutex.synchronize { list.select { |i| @set.include?(key_for(i)) } }
      end

      def mark_unsubscribed!(list)
        @mutex.synchronize { list.each { |i| @set.delete(key_for(i)) } }
      end

      def snapshot
        @mutex.synchronize { @set.to_a }
      end

      private

      def key_for(i) = "#{i[:ExchangeSegment]}:#{i[:SecurityId]}"
    end
  end
end


# File: lib/DhanHQ/ws/websocket_packet_parser.rb
# frozen_string_literal: true

require "stringio"

require_relative "packets/header"
require_relative "packets/ticker_packet"
require_relative "packets/quote_packet"
require_relative "packets/full_packet"
require_relative "packets/oi_packet"
require_relative "packets/prev_close_packet"
require_relative "packets/disconnect_packet"
require_relative "packets/index_packet"
require_relative "packets/market_status_packet"
# optional:
require_relative "packets/depth_delta_packet"

module DhanHQ
  module WS
    class WebsocketPacketParser
      RESPONSE_CODES = {
        index: 1,
        ticker: 2,
        quote: 4,
        oi: 5,
        prev_close: 6,
        full: 8,
        depth_bid: 41,
        depth_ask: 51,
        disconnect: 50
      }.freeze

      attr_reader :binary_data, :binary_stream, :header

      def initialize(binary_data)
        @binary_data   = binary_data
        @header        = Packets::Header.read(@binary_data) # 8 bytes header
        @binary_stream = StringIO.new(@binary_data.byteslice(8..) || "".b) # payload only
      end

      def parse
        body =
          case header.feed_response_code
          when RESPONSE_CODES[:index]       then parse_index
          when RESPONSE_CODES[:ticker]      then parse_ticker
          when RESPONSE_CODES[:quote]       then parse_quote
          when RESPONSE_CODES[:oi]          then parse_oi
          when RESPONSE_CODES[:prev_close]  then parse_prev_close
          when RESPONSE_CODES[:market_status] then parse_market_status
          when RESPONSE_CODES[:full]        then parse_full
          when RESPONSE_CODES[:depth_bid]   then parse_depth(:bid)
          when RESPONSE_CODES[:depth_ask]   then parse_depth(:ask)
          when RESPONSE_CODES[:disconnect]  then parse_disconnect
          else
            DhanHQ.logger&.debug("[WS::Parser] Unknown feed code=#{header.feed_response_code}")
            {}
          end

        {
          feed_response_code: header.feed_response_code,
          message_length: header.message_length,
          exchange_segment: header.exchange_segment, # numeric (0/1/2/…)
          security_id: header.security_id
        }.merge(body)
      rescue StandardError => e
        DhanHQ.logger.error "[WS::Parser] ❌ #{e.class}: #{e.message}"
        {}
      end

      private

      def parse_index
        rec = Packets::IndexPacket.new(@binary_stream.string)
        { index_raw: rec.raw } # keep raw until official layout is known
      end

      def parse_market_status
        rec = Packets::MarketStatusPacket.new(@binary_stream.string)
        { market_status_raw: rec.raw } # keep raw until official layout is known
      end

      def parse_ticker
        rec = Packets::TickerPacket.read(@binary_stream.string)
        { ltp: rec.ltp, ltt: rec.ltt }
      end

      def parse_quote
        rec = Packets::QuotePacket.read(@binary_stream.string)

        {
          ltp: rec.ltp,
          last_trade_qty: rec.last_trade_qty,
          ltt: rec.ltt,
          atp: rec.atp,
          volume: rec.volume,
          total_sell_qty: rec.total_sell_qty,
          total_buy_qty: rec.total_buy_qty,
          day_open: rec.day_open,
          day_close: rec.day_close,
          day_high: rec.day_high,
          day_low: rec.day_low
        }
      end

      def parse_full
        rec = Packets::FullPacket.read(@binary_stream.string)
        {
          ltp: rec.ltp,
          last_trade_qty: rec.last_trade_qty,
          ltt: rec.ltt,
          atp: rec.atp,
          volume: rec.volume,
          total_sell_qty: rec.total_sell_qty,
          total_buy_qty: rec.total_buy_qty,
          open_interest: rec.open_interest,
          highest_open_interest: rec.highest_oi,
          lowest_open_interest: rec.lowest_oi,
          day_open: rec.day_open,
          day_close: rec.day_close,
          day_high: rec.day_high,
          day_low: rec.day_low,
          market_depth: rec.market_depth
        }
      end

      def parse_oi
        rec = Packets::OiPacket.read(@binary_stream.string)
        { open_interest: rec.open_interest }
      end

      def parse_prev_close
        rec = Packets::PrevClosePacket.read(@binary_stream.string)
        { prev_close: rec.prev_close, oi_prev: rec.oi_prev }
      end

      # depth_bid / depth_ask incremental
      def parse_depth(side)
        rec = Packets::DepthDeltaPacket.read(@binary_stream.string)
        {
          depth_side: side,
          bid_quantity: rec.bid_quantity,
          ask_quantity: rec.ask_quantity,
          no_of_bid_orders: rec.no_of_bid_orders,
          no_of_ask_orders: rec.no_of_ask_orders,
          bid_price: rec.bid_price,
          ask_price: rec.ask_price
        }
      end

      def parse_disconnect
        {
          disconnection_code: binary_stream.read(2).unpack1("s>")
        }
      end

      def debug_log(data)
        DhanHQ.logger.debug { "[WS::Parser] Parsed: #{data.inspect}" }
      end
    end
  end
end


# File: lib/DhanHQ/ws.rb
# frozen_string_literal: true

require_relative "ws/client"

module DhanHQ
  module WS
    # One-liner convenience:
    # client = DhanHQ::WS.connect(mode: :ticker) { |tick| puts tick.inspect }
    def self.connect(mode: :ticker, &on_tick)
      Client.new(mode: mode).start.on(:tick, &on_tick)
    end

    # Manual nuke switch for current process
    def self.disconnect_all_local!
      Registry.stop_all
    end
  end
end


# File: lib/DhanHQ.rb
# frozen_string_literal: true

require "dotenv/load"
require "logger"

# Helper Methods
require_relative "DhanHQ/helpers/api_helper"
require_relative "DhanHQ/helpers/attribute_helper"
require_relative "DhanHQ/helpers/validation_helper"
require_relative "DhanHQ/helpers/request_helper"
require_relative "DhanHQ/helpers/response_helper"
require_relative "DhanHQ/json_loader"

require_relative "DhanHQ/core/base_api"
require_relative "DhanHQ/core/base_resource"
require_relative "DhanHQ/core/base_model"
require_relative "DhanHQ/core/error_handler"

require_relative "DhanHQ/version"
require_relative "DhanHQ/errors"
require_relative "DhanHQ/error_object"

require_relative "DhanHQ/client"
require_relative "DhanHQ/configuration"
require_relative "DhanHQ/rate_limiter"

# Contracts
require_relative "DhanHQ/contracts/base_contract"
require_relative "DhanHQ/contracts/historical_data_contract"

# Resources
require_relative "DhanHQ/resources/option_chain"
require_relative "DhanHQ/resources/orders"
require_relative "DhanHQ/resources/forever_orders"
require_relative "DhanHQ/resources/super_orders"
require_relative "DhanHQ/resources/funds"
require_relative "DhanHQ/resources/holdings"
require_relative "DhanHQ/resources/positions"
require_relative "DhanHQ/resources/statements"
require_relative "DhanHQ/resources/trades"
require_relative "DhanHQ/resources/historical_data"
require_relative "DhanHQ/resources/margin_calculator"
require_relative "DhanHQ/resources/market_feed"

# Models
require_relative "DhanHQ/models/order"
require_relative "DhanHQ/models/funds"
require_relative "DhanHQ/models/option_chain"
require_relative "DhanHQ/models/forever_order"
require_relative "DhanHQ/models/super_order"
require_relative "DhanHQ/models/historical_data"
require_relative "DhanHQ/models/market_feed"
require_relative "DhanHQ/models/position"
require_relative "DhanHQ/models/holding"
require_relative "DhanHQ/models/ledger_entry"
require_relative "DhanHQ/models/trade"
require_relative "DhanHQ/models/margin"

require_relative "DhanHQ/constants"
require_relative "DhanHQ/ws"
require_relative "DhanHQ/ws/singleton_lock"

# The top-level module for the DhanHQ client library.
#
# Provides configuration management for setting credentials and API-related settings.
module DhanHQ
  class Error < StandardError; end

  class << self
    BASE_URL = "https://api.dhan.co/v2"
    # The current configuration instance.
    #
    # @return [DhanHQ::Configuration, nil] The current configuration or `nil` if not set.
    attr_accessor :configuration

    attr_writer :logger

    # Configures the DhanHQ client with user-defined settings.
    #
    # @example
    #   DhanHQ.configure do |config|
    #     config.access_token = 'your_access_token'
    #     config.client_id = 'your_client_id'
    #   end
    #
    # @yieldparam [DhanHQ::Configuration] configuration The configuration object.
    # @return [void]
    def configure
      self.configuration ||= Configuration.new
      yield(configuration)
      self.logger ||= Logger.new($stdout, level: Logger::INFO)
    end

    # default logger so calls like DhanHQ.logger&.info never explode
    def logger
      @logger ||= Logger.new($stdout, level: Logger::INFO)
    end

    # Configures the DhanHQ client with user-defined settings.
    #
    # @example
    #   DhanHQ.configure_with_env
    #
    # @return [void]
    def configure_with_env
      self.configuration ||= Configuration.new
      configuration.access_token = ENV.fetch("ACCESS_TOKEN", nil)
      configuration.client_id = ENV.fetch("CLIENT_ID", nil)
      configuration.base_url = BASE_URL
    end
  end
end


