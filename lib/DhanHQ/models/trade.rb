# frozen_string_literal: true

module DhanHQ
  module Models
    ##
    # Model for retrieving trade execution details.
    #
    # The Trade Book API lets you retrieve an array of all trades executed in a day.
    # You can also fetch trade details for a specific order ID, which is useful during
    # partial trades or Bracket/Cover Orders. Additionally, you can retrieve detailed
    # trade history for all orders within a particular time frame.
    #
    # @example Fetch all trades for today
    #   trades = DhanHQ::Models::Trade.today
    #   trades.each do |trade|
    #     puts "#{trade.trading_symbol}: #{trade.traded_quantity} @ ₹#{trade.traded_price}"
    #     puts "Total Value: ₹#{trade.total_value}, Charges: ₹#{trade.total_charges}"
    #   end
    #
    # @example Fetch trades for a specific order
    #   trade = DhanHQ::Models::Trade.find_by_order_id("112111182045")
    #   if trade
    #     puts "Traded: #{trade.traded_quantity} @ ₹#{trade.traded_price}"
    #   end
    #
    # @example Fetch historical trades
    #   trades = DhanHQ::Models::Trade.history(
    #     from_date: "2022-12-01",
    #     to_date: "2022-12-31",
    #     page: 0
    #   )
    #   total_value = trades.sum(&:total_value)
    #   puts "Total traded value: ₹#{total_value}"
    #
    class Trade < BaseModel
      HTTP_PATH = "/v2/trades"

      # All trade attributes as per API documentation
      attributes :dhan_client_id, :order_id, :exchange_order_id, :exchange_trade_id,
                 :transaction_type, :exchange_segment, :product_type, :order_type,
                 :trading_symbol, :custom_symbol, :security_id, :traded_quantity,
                 :traded_price, :isin, :instrument, :sebi_tax, :stt, :brokerage_charges,
                 :service_tax, :exchange_transaction_charges, :stamp_duty,
                 :create_time, :update_time, :exchange_time, :drv_expiry_date,
                 :drv_option_type, :drv_strike_price

      class << self
        ##
        # Provides a shared instance of the Trades resource for current day tradebook APIs.
        #
        # @return [DhanHQ::Resources::Trades] The Trades resource client instance
        def tradebook_resource
          @tradebook_resource ||= DhanHQ::Resources::Trades.new
        end

        ##
        # Provides a shared instance of the Statements resource for historical trade data.
        #
        # @return [DhanHQ::Resources::Statements] The Statements resource client instance
        def statements_resource
          @statements_resource ||= DhanHQ::Resources::Statements.new
        end

        ##
        # Retrieves all trades executed during the current trading day.
        #
        # Fetches an array of all trades executed in the day. This is useful for
        # tracking daily execution activity and analyzing trade performance.
        #
        # @return [Array<Trade>] Array of Trade objects. Returns empty array if no trades exist.
        #   Each Trade object contains (keys normalized to snake_case):
        #   - **:dhan_client_id** [String] User-specific identification generated by Dhan
        #   - **:order_id** [String] Order-specific identification generated by Dhan
        #   - **:exchange_order_id** [String] Order-specific identification generated by exchange
        #   - **:exchange_trade_id** [String] Trade-specific identification generated by exchange
        #   - **:transaction_type** [String] The trading side of transaction. "BUY" or "SELL"
        #   - **:exchange_segment** [String] Exchange segment of instrument
        #   - **:product_type** [String] Product type. Valid values: "CNC", "INTRADAY",
        #     "MARGIN", "MTF", "CO", "BO"
        #   - **:order_type** [String] Order type. Valid values: "LIMIT", "MARKET",
        #     "STOP_LOSS", "STOP_LOSS_MARKET"
        #   - **:trading_symbol** [String] Trading symbol of the instrument
        #   - **:security_id** [String] Exchange standard ID for each scrip
        #   - **:traded_quantity** [Integer] Number of shares executed
        #   - **:traded_price** [Float] Price at which trade is executed
        #   - **:create_time** [String] Time at which the order is created
        #   - **:update_time** [String] Time at which the last activity happened
        #   - **:exchange_time** [String] Time at which order reached at exchange
        #   - **:drv_expiry_date** [String, nil] For F&O, expiry date of contract
        #   - **:drv_option_type** [String, nil] Type of Option. "CALL" or "PUT"
        #   - **:drv_strike_price** [Float] For Options, Strike Price
        #
        # @example Fetch and analyze today's trades
        #   trades = DhanHQ::Models::Trade.today
        #   buy_trades = trades.select(&:buy?)
        #   sell_trades = trades.select(&:sell?)
        #   puts "Buy trades: #{buy_trades.count}, Sell trades: #{sell_trades.count}"
        #   total_value = trades.sum(&:total_value)
        #   puts "Total traded value: ₹#{total_value}"
        #
        # @example Calculate P&L for today
        #   trades = DhanHQ::Models::Trade.today
        #   buy_value = trades.select(&:buy?).sum(&:total_value)
        #   sell_value = trades.select(&:sell?).sum(&:total_value)
        #   total_charges = trades.sum(&:total_charges)
        #   pnl = sell_value - buy_value - total_charges
        #   puts "P&L: ₹#{pnl}"
        #
        def today
          response = tradebook_resource.all
          parse_collection_response(response)
        end

        ##
        # Retrieves trade details for a specific order ID (current day).
        #
        # Fetches all trades generated for a particular order ID. This is especially useful
        # during partial trades or Bracket/Cover Orders where traders may get confused
        # reading trades from the tradebook. The response includes all trades generated
        # for the specified order ID.
        #
        # @param order_id [String] Order-specific identification generated by Dhan
        #
        # @return [Trade, nil] Trade object with trade details if found, nil otherwise.
        #   Response structure is the same as {today}.
        #
        # @example Fetch trade for an order
        #   trade = DhanHQ::Models::Trade.find_by_order_id("112111182045")
        #   if trade
        #     puts "Order: #{trade.order_id}"
        #     puts "Traded: #{trade.traded_quantity} @ ₹#{trade.traded_price}"
        #     puts "Symbol: #{trade.trading_symbol}"
        #     puts "Time: #{trade.exchange_time}"
        #   end
        #
        # @raise [DhanHQ::ValidationError] If order_id validation fails
        def find_by_order_id(order_id)
          # Validate input
          contract = DhanHQ::Contracts::TradeByOrderIdContract.new
          validation_result = contract.call(order_id: order_id)

          unless validation_result.success?
            raise DhanHQ::ValidationError, "Invalid order_id: #{validation_result.errors.to_h}"
          end

          response = tradebook_resource.find(order_id)
          return nil unless response.is_a?(Hash) || (response.is_a?(Array) && response.any?)

          data = response.is_a?(Array) ? response.first : response
          new(data, skip_validation: true)
        end

        ##
        # Retrieves detailed trade history for all orders within a specified time frame.
        #
        # Fetches paginated trade history data with comprehensive charge breakdowns.
        # The response includes detailed information about SEBI tax, STT, brokerage charges,
        # service tax, exchange transaction charges, and stamp duty for each trade.
        #
        # @param from_date [String] (required) Start date in "YYYY-MM-DD" format
        # @param to_date [String] (required) End date in "YYYY-MM-DD" format
        # @param page [Integer] (default: 0) Page number for paginated results. Pass 0 for first page
        #
        # @return [Array<Trade>] Array of historical Trade objects. Returns empty array if no trades found.
        #   Each Trade object contains all fields from {today} plus additional charge details:
        #   - **:custom_symbol** [String] Trading Symbol as per Dhan
        #   - **:isin** [String] Universal standard ID for each scrip (International Securities Identification Number)
        #   - **:instrument** [String] Type of Instrument. "EQUITY" or "DERIVATIVES"
        #   - **:sebi_tax** [String] SEBI Turnover Charges
        #   - **:stt** [String] Securities Transactions Tax
        #   - **:brokerage_charges** [String] Brokerage charges by Dhan
        #   - **:service_tax** [String] Applicable Service Tax
        #   - **:exchange_transaction_charges** [String] Exchange Transaction Charge
        #   - **:stamp_duty** [String] Stamp Duty Charges
        #
        # @example Fetch historical trades for a month
        #   trades = DhanHQ::Models::Trade.history(
        #     from_date: "2022-12-01",
        #     to_date: "2022-12-31",
        #     page: 0
        #   )
        #   puts "Total trades: #{trades.count}"
        #
        # @example Calculate total charges for historical period
        #   trades = DhanHQ::Models::Trade.history(
        #     from_date: "2022-12-01",
        #     to_date: "2022-12-31"
        #   )
        #   total_charges = trades.sum(&:total_charges)
        #   total_brokerage = trades.sum { |t| t.brokerage_charges.to_f }
        #   puts "Total Charges: ₹#{total_charges}"
        #   puts "Total Brokerage: ₹#{total_brokerage}"
        #
        # @example Paginate through historical trades
        #   page = 0
        #   loop do
        #     trades = DhanHQ::Models::Trade.history(
        #       from_date: "2022-12-01",
        #       to_date: "2022-12-31",
        #       page: page
        #     )
        #     break if trades.empty?
        #
        #     puts "Page #{page}: #{trades.count} trades"
        #     page += 1
        #   end
        #
        # @raise [DhanHQ::ValidationError] If date format or page validation fails
        def history(from_date:, to_date:, page: 0)
          validate_history_params(from_date, to_date, page)

          response = statements_resource.trade_history(
            from_date: from_date,
            to_date: to_date,
            page: page
          )

          return [] unless response.is_a?(Array)

          response.map { |trade_data| new(trade_data, skip_validation: true) }
        end

        private

        ##
        # Validates parameters for historical trade queries.
        #
        # @param from_date [String] Start date in YYYY-MM-DD format
        # @param to_date [String] End date in YYYY-MM-DD format
        # @param page [Integer] Page number
        #
        # @raise [DhanHQ::ValidationError] If validation fails
        #
        # @api private
        def validate_history_params(from_date, to_date, page)
          contract = DhanHQ::Contracts::TradeHistoryContract.new
          validation_result = contract.call(from_date: from_date, to_date: to_date, page: page)

          return if validation_result.success?

          raise DhanHQ::ValidationError, "Invalid parameters: #{validation_result.errors.to_h}"
        end

        # Alias for backward compatibility with historical trades
        # @api private
        alias all history
      end

      ##
      # Trade objects are read-only, so no validation contract needed.
      #
      # @return [nil] Always returns nil as trades are read-only
      #
      # @api private
      def validation_contract
        nil
      end

      ##
      # Checks if the trade is a BUY transaction.
      #
      # @return [Boolean] true if transaction_type is "BUY", false otherwise
      #
      # @example
      #   trade = DhanHQ::Models::Trade.today.first
      #   if trade.buy?
      #     puts "This is a buy trade"
      #   end
      #
      def buy?
        transaction_type == DhanHQ::Constants::TransactionType::BUY
      end

      ##
      # Checks if the trade is a SELL transaction.
      #
      # @return [Boolean] true if transaction_type is "SELL", false otherwise
      #
      # @example
      #   trade = DhanHQ::Models::Trade.today.first
      #   if trade.sell?
      #     puts "This is a sell trade"
      #   end
      #
      def sell?
        transaction_type == DhanHQ::Constants::TransactionType::SELL
      end

      ##
      # Checks if the trade instrument is EQUITY.
      #
      # @return [Boolean] true if instrument is "EQUITY", false otherwise
      #
      # @example
      #   trades = DhanHQ::Models::Trade.today
      #   equity_trades = trades.select(&:equity?)
      #   puts "Equity trades: #{equity_trades.count}"
      #
      def equity?
        instrument == DhanHQ::Constants::InstrumentType::EQUITY
      end

      ##
      # Checks if the trade instrument is DERIVATIVES.
      #
      # @return [Boolean] true if instrument is "DERIVATIVES", false otherwise
      #
      # @example
      #   trades = DhanHQ::Models::Trade.today
      #   derivative_trades = trades.select(&:derivative?)
      #   puts "Derivative trades: #{derivative_trades.count}"
      #
      def derivative?
        instrument == "DERIVATIVES"
      end

      ##
      # Checks if the trade is an option (CALL or PUT).
      #
      # @return [Boolean] true if drv_option_type is "CALL" or "PUT", false otherwise
      #
      # @example
      #   trades = DhanHQ::Models::Trade.today
      #   option_trades = trades.select(&:option?)
      #   puts "Option trades: #{option_trades.count}"
      #
      def option?
        [DhanHQ::Constants::OptionType::CALL, DhanHQ::Constants::OptionType::PUT].include?(drv_option_type)
      end

      ##
      # Checks if the trade is a CALL option.
      #
      # @return [Boolean] true if drv_option_type is "CALL", false otherwise
      #
      # @example
      #   trades = DhanHQ::Models::Trade.today
      #   call_trades = trades.select(&:call_option?)
      #   puts "Call option trades: #{call_trades.count}"
      #
      def call_option?
        drv_option_type == DhanHQ::Constants::OptionType::CALL
      end

      ##
      # Checks if the trade is a PUT option.
      #
      # @return [Boolean] true if drv_option_type is "PUT", false otherwise
      #
      # @example
      #   trades = DhanHQ::Models::Trade.today
      #   put_trades = trades.select(&:put_option?)
      #   puts "Put option trades: #{put_trades.count}"
      #
      def put_option?
        drv_option_type == DhanHQ::Constants::OptionType::PUT
      end

      ##
      # Calculates the total trade value (quantity × price).
      #
      # @return [Float] Total trade value. Returns 0 if traded_quantity or traded_price is missing
      #
      # @example
      #   trade = DhanHQ::Models::Trade.today.first
      #   puts "Trade Value: ₹#{trade.total_value}"
      #   # => Trade Value: ₹133832.0
      #
      def total_value
        return 0 unless traded_quantity && traded_price

        traded_quantity * traded_price
      end

      ##
      # Calculates the total charges for the trade.
      #
      # Sums all applicable charges including SEBI tax, STT, brokerage charges,
      # service tax, exchange transaction charges, and stamp duty.
      #
      # @return [Float] Total charges amount. Returns 0 if no charges are present
      #
      # @example
      #   trade = DhanHQ::Models::Trade.history(
      #     from_date: "2022-12-01",
      #     to_date: "2022-12-31"
      #   ).first
      #   puts "Total Charges: ₹#{trade.total_charges}"
      #   puts "Brokerage: ₹#{trade.brokerage_charges}"
      #   puts "STT: ₹#{trade.stt}"
      #
      def total_charges
        charges = [sebi_tax, stt, brokerage_charges, service_tax,
                   exchange_transaction_charges, stamp_duty].compact
        charges.sum(&:to_f)
      end

      ##
      # Calculates the net trade value after deducting all charges.
      #
      # @return [Float] Net trade value (total_value - total_charges)
      #
      # @example
      #   trade = DhanHQ::Models::Trade.history(
      #     from_date: "2022-12-01",
      #     to_date: "2022-12-31"
      #   ).first
      #   puts "Gross Value: ₹#{trade.total_value}"
      #   puts "Charges: ₹#{trade.total_charges}"
      #   puts "Net Value: ₹#{trade.net_value}"
      #
      def net_value
        total_value - total_charges
      end
    end
  end
end
